import React, { forwardRef, useState, useRef, useCallback, useMemo, useEffect } from 'react';
import cn from 'classnames';
import mergeRefs from 'react-merge-refs';
import { ResizeObserver } from 'resize-observer';
import { CSSTransition } from 'react-transition-group';
import FocusLock from 'react-focus-lock';
import { Portal } from '../../portal/esm';
import { Backdrop } from '../../backdrop/esm';
import { stackingOrder, Stack } from '../../stack/esm';
import '../../global-store/esm';
import { isScrolledToTop, isScrolledToBottom, handleContainer, restoreContainerStyles, hasScrollbar } from './utils.js';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function () {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var styles = {"component":"base-modal__component_jezo0","wrapper":"base-modal__wrapper_jezo0","content":"base-modal__content_jezo0","hidden":"base-modal__hidden_jezo0","backdrop":"base-modal__backdrop_jezo0","appear":"base-modal__appear_jezo0","enter":"base-modal__enter_jezo0","appearActive":"base-modal__appearActive_jezo0","enterActive":"base-modal__enterActive_jezo0","exit":"base-modal__exit_jezo0","exitActive":"base-modal__exitActive_jezo0","exitDone":"base-modal__exitDone_jezo0"};
require('./index.css');

var BaseModalContext = React.createContext({
    hasFooter: false,
    hasHeader: false,
    hasScroll: false,
    headerHighlighted: false,
    footerHighlighted: false,
    contentRef: function () { return null; },
    setHasHeader: function () { return null; },
    setHasFooter: function () { return null; },
    onClose: function () { return null; },
});
var BaseModal = forwardRef(function (_a, ref) {
    var open = _a.open, container = _a.container, children = _a.children, _b = _a.scrollHandler, scrollHandler = _b === void 0 ? 'wrapper' : _b, _c = _a.Backdrop, Backdrop$1 = _c === void 0 ? Backdrop : _c, _d = _a.backdropProps, backdropProps = _d === void 0 ? {} : _d, _e = _a.transitionProps, transitionProps = _e === void 0 ? {} : _e, disableBackdropClick = _a.disableBackdropClick, _f = _a.disableAutoFocus, disableAutoFocus = _f === void 0 ? false : _f, _g = _a.disableFocusLock, disableFocusLock = _g === void 0 ? false : _g, _h = _a.disableEscapeKeyDown, disableEscapeKeyDown = _h === void 0 ? false : _h, _j = _a.disableRestoreFocus, disableRestoreFocus = _j === void 0 ? false : _j, _k = _a.keepMounted, keepMounted = _k === void 0 ? false : _k, className = _a.className, contentClassName = _a.contentClassName, wrapperClassName = _a.wrapperClassName, onBackdropClick = _a.onBackdropClick, onClose = _a.onClose, onEscapeKeyDown = _a.onEscapeKeyDown, onMount = _a.onMount, onUnmount = _a.onUnmount, dataTestId = _a.dataTestId, _l = _a.zIndex, zIndex = _l === void 0 ? stackingOrder.MODAL : _l;
    var _m = useState(!open), exited = _m[0], setExited = _m[1];
    var _o = useState(false), hasScroll = _o[0], setHasScroll = _o[1];
    var _p = useState(false), hasHeader = _p[0], setHasHeader = _p[1];
    var _q = useState(false), hasFooter = _q[0], setHasFooter = _q[1];
    var _r = useState(false), headerHighlighted = _r[0], setHeaderHighlighted = _r[1];
    var _s = useState(false), footerHighlighted = _s[0], setFooterHighlighted = _s[1];
    var componentRef = useRef(null);
    var wrapperRef = useRef(null);
    var scrollableNodeRef = useRef(null);
    var contentNodeRef = useRef(null);
    var restoreContainerStylesRef = useRef(null);
    var checkToHasScrollBar = function () {
        if (scrollableNodeRef.current) {
            var scrollExists = hasScrollbar(scrollableNodeRef.current);
            setFooterHighlighted(scrollExists);
            setHasScroll(scrollExists);
        }
    };
    var shouldRender = keepMounted || open || !exited;
    var getContainer = useCallback(function () {
        return (container ? container() : document.body);
    }, [container]);
    var resizeObserver = useMemo(function () { return new ResizeObserver(checkToHasScrollBar); }, []);
    var addResizeHandle = useCallback(function () {
        if (scrollableNodeRef.current)
            resizeObserver.observe(scrollableNodeRef.current);
        if (contentNodeRef.current)
            resizeObserver.observe(contentNodeRef.current);
    }, [resizeObserver]);
    var removeResizeHandle = useCallback(function () {
        resizeObserver.disconnect();
    }, [resizeObserver]);
    var contentRef = useCallback(function (node) {
        if (node !== null) {
            contentNodeRef.current = node;
            resizeObserver.observe(node);
            checkToHasScrollBar();
        }
    }, [resizeObserver]);
    var handleScroll = useCallback(function () {
        if (!scrollableNodeRef.current || !componentRef.current)
            return;
        if (hasHeader) {
            setHeaderHighlighted(!isScrolledToTop(scrollableNodeRef.current) &&
                componentRef.current.getBoundingClientRect().top <= 0);
        }
        if (hasFooter) {
            setFooterHighlighted(!isScrolledToBottom(scrollableNodeRef.current) &&
                componentRef.current.getBoundingClientRect().bottom >= window.innerHeight);
        }
    }, [hasFooter, hasHeader]);
    var handleClose = useCallback(function (event, reason) {
        if (onClose) {
            onClose(event, reason);
        }
        if (reason === 'backdropClick' && onBackdropClick) {
            onBackdropClick(event);
        }
        if (reason === 'escapeKeyDown' && onEscapeKeyDown) {
            onEscapeKeyDown(event);
        }
        return null;
    }, [onBackdropClick, onClose, onEscapeKeyDown]);
    var handleBackdropClick = function (event) {
        if (!disableBackdropClick && event.target === wrapperRef.current) {
            handleClose(event, 'backdropClick');
        }
    };
    var handleKeyDown = useCallback(function (event) {
        /*
         * Чтобы сохранить дефолтное поведение элементов и событий форм,
         * обработчик не устанавливает event.preventDefault()
         */
        if (event.key !== 'Escape') {
            return;
        }
        // Если есть обработчик escape на body
        event.stopPropagation();
        if (!disableEscapeKeyDown && handleClose) {
            handleClose(event, 'escapeKeyDown');
        }
    }, [disableEscapeKeyDown, handleClose]);
    var getScrollHandler = useCallback(function () {
        if (scrollHandler === 'wrapper')
            return wrapperRef.current;
        if (scrollHandler === 'content')
            return componentRef.current;
        return scrollHandler.current || wrapperRef.current;
    }, [scrollHandler]);
    var handleEntered = useCallback(function (node, isAppearing) {
        scrollableNodeRef.current = getScrollHandler();
        addResizeHandle();
        if (scrollableNodeRef.current) {
            scrollableNodeRef.current.addEventListener('scroll', handleScroll);
            handleScroll();
        }
        if (transitionProps.onEntered) {
            transitionProps.onEntered(node, isAppearing);
        }
        if (onMount)
            onMount();
    }, [addResizeHandle, getScrollHandler, handleScroll, onMount, transitionProps]);
    var handleExited = useCallback(function (node) {
        removeResizeHandle();
        setExited(true);
        if (scrollableNodeRef.current) {
            scrollableNodeRef.current.removeEventListener('scroll', handleScroll);
        }
        if (transitionProps.onExited) {
            transitionProps.onExited(node);
        }
        if (onUnmount)
            onUnmount();
        if (restoreContainerStylesRef.current) {
            restoreContainerStylesRef.current();
        }
    }, [handleScroll, onUnmount, removeResizeHandle, transitionProps]);
    useEffect(function () {
        if (open) {
            handleContainer(getContainer());
            restoreContainerStylesRef.current = function () {
                restoreContainerStylesRef.current = null;
                restoreContainerStyles(getContainer());
            };
        }
    }, [getContainer, open]);
    useEffect(function () {
        if (open)
            setExited(false);
    }, [open]);
    useEffect(function () {
        return function () {
            if (restoreContainerStylesRef.current) {
                restoreContainerStylesRef.current();
            }
            resizeObserver.disconnect();
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var contextValue = useMemo(function () { return ({
        hasHeader: hasHeader,
        hasFooter: hasFooter,
        hasScroll: hasScroll,
        headerHighlighted: headerHighlighted,
        footerHighlighted: footerHighlighted,
        contentRef: contentRef,
        setHasHeader: setHasHeader,
        setHasFooter: setHasFooter,
        onClose: handleClose,
    }); }, [
        contentRef,
        hasHeader,
        hasFooter,
        hasScroll,
        headerHighlighted,
        footerHighlighted,
        handleClose,
    ]);
    if (!shouldRender)
        return null;
    return (React.createElement(Stack, { value: zIndex }, function (computedZIndex) {
        var _a;
        return (React.createElement(Portal, { getPortalContainer: container },
            React.createElement(BaseModalContext.Provider, { value: contextValue },
                React.createElement(FocusLock, { autoFocus: !disableAutoFocus, disabled: disableFocusLock || !open, returnFocus: !disableRestoreFocus },
                    Backdrop$1 && (React.createElement(Backdrop$1, __assign({}, backdropProps, { className: cn(backdropProps.className, styles.backdrop), open: open, style: {
                            zIndex: computedZIndex,
                        } }))),
                    React.createElement("div", { role: 'dialog', className: cn(styles.wrapper, wrapperClassName, (_a = {},
                            _a[styles.hidden] = !open && exited,
                            _a)), ref: mergeRefs([ref, wrapperRef]), onKeyDown: handleKeyDown, onClick: handleBackdropClick, tabIndex: -1, "data-test-id": dataTestId, style: {
                            zIndex: computedZIndex,
                        } },
                        React.createElement(CSSTransition, __assign({ appear: true, timeout: 200, classNames: styles }, transitionProps, { in: open, onEntered: handleEntered, onExited: handleExited }),
                            React.createElement("div", { className: cn(styles.component, className), ref: componentRef },
                                React.createElement("div", { className: cn(styles.content, contentClassName) }, children))))))));
    }));
});

export { BaseModal, BaseModalContext };
