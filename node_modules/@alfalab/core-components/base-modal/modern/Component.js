import React, { forwardRef, useState, useRef, useCallback, useMemo, useEffect } from 'react';
import cn from 'classnames';
import mergeRefs from 'react-merge-refs';
import { ResizeObserver } from 'resize-observer';
import { CSSTransition } from 'react-transition-group';
import FocusLock from 'react-focus-lock';
import { Portal } from '../../portal/modern';
import { Backdrop } from '../../backdrop/modern';
import { stackingOrder, Stack } from '../../stack/modern';
import '../../global-store/modern';
import { isScrolledToTop, isScrolledToBottom, handleContainer, restoreContainerStyles, hasScrollbar } from './utils.js';

var styles = {"component":"base-modal__component_jezo0","wrapper":"base-modal__wrapper_jezo0","content":"base-modal__content_jezo0","hidden":"base-modal__hidden_jezo0","backdrop":"base-modal__backdrop_jezo0","appear":"base-modal__appear_jezo0","enter":"base-modal__enter_jezo0","appearActive":"base-modal__appearActive_jezo0","enterActive":"base-modal__enterActive_jezo0","exit":"base-modal__exit_jezo0","exitActive":"base-modal__exitActive_jezo0","exitDone":"base-modal__exitDone_jezo0"};
require('./index.css');

/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */
const BaseModalContext = React.createContext({
    hasFooter: false,
    hasHeader: false,
    hasScroll: false,
    headerHighlighted: false,
    footerHighlighted: false,
    contentRef: () => null,
    setHasHeader: () => null,
    setHasFooter: () => null,
    onClose: () => null,
});
const BaseModal = forwardRef(({ open, container, children, scrollHandler = 'wrapper', Backdrop: Backdrop$1 = Backdrop, backdropProps = {}, transitionProps = {}, disableBackdropClick, disableAutoFocus = false, disableFocusLock = false, disableEscapeKeyDown = false, disableRestoreFocus = false, keepMounted = false, className, contentClassName, wrapperClassName, onBackdropClick, onClose, onEscapeKeyDown, onMount, onUnmount, dataTestId, zIndex = stackingOrder.MODAL, }, ref) => {
    const [exited, setExited] = useState(!open);
    const [hasScroll, setHasScroll] = useState(false);
    const [hasHeader, setHasHeader] = useState(false);
    const [hasFooter, setHasFooter] = useState(false);
    const [headerHighlighted, setHeaderHighlighted] = useState(false);
    const [footerHighlighted, setFooterHighlighted] = useState(false);
    const componentRef = useRef(null);
    const wrapperRef = useRef(null);
    const scrollableNodeRef = useRef(null);
    const contentNodeRef = useRef(null);
    const restoreContainerStylesRef = useRef(null);
    const checkToHasScrollBar = () => {
        if (scrollableNodeRef.current) {
            const scrollExists = hasScrollbar(scrollableNodeRef.current);
            setFooterHighlighted(scrollExists);
            setHasScroll(scrollExists);
        }
    };
    const shouldRender = keepMounted || open || !exited;
    const getContainer = useCallback(() => {
        return (container ? container() : document.body);
    }, [container]);
    const resizeObserver = useMemo(() => new ResizeObserver(checkToHasScrollBar), []);
    const addResizeHandle = useCallback(() => {
        if (scrollableNodeRef.current)
            resizeObserver.observe(scrollableNodeRef.current);
        if (contentNodeRef.current)
            resizeObserver.observe(contentNodeRef.current);
    }, [resizeObserver]);
    const removeResizeHandle = useCallback(() => {
        resizeObserver.disconnect();
    }, [resizeObserver]);
    const contentRef = useCallback((node) => {
        if (node !== null) {
            contentNodeRef.current = node;
            resizeObserver.observe(node);
            checkToHasScrollBar();
        }
    }, [resizeObserver]);
    const handleScroll = useCallback(() => {
        if (!scrollableNodeRef.current || !componentRef.current)
            return;
        if (hasHeader) {
            setHeaderHighlighted(!isScrolledToTop(scrollableNodeRef.current) &&
                componentRef.current.getBoundingClientRect().top <= 0);
        }
        if (hasFooter) {
            setFooterHighlighted(!isScrolledToBottom(scrollableNodeRef.current) &&
                componentRef.current.getBoundingClientRect().bottom >= window.innerHeight);
        }
    }, [hasFooter, hasHeader]);
    const handleClose = useCallback((event, reason) => {
        if (onClose) {
            onClose(event, reason);
        }
        if (reason === 'backdropClick' && onBackdropClick) {
            onBackdropClick(event);
        }
        if (reason === 'escapeKeyDown' && onEscapeKeyDown) {
            onEscapeKeyDown(event);
        }
        return null;
    }, [onBackdropClick, onClose, onEscapeKeyDown]);
    const handleBackdropClick = (event) => {
        if (!disableBackdropClick && event.target === wrapperRef.current) {
            handleClose(event, 'backdropClick');
        }
    };
    const handleKeyDown = useCallback((event) => {
        /*
         * Чтобы сохранить дефолтное поведение элементов и событий форм,
         * обработчик не устанавливает event.preventDefault()
         */
        if (event.key !== 'Escape') {
            return;
        }
        // Если есть обработчик escape на body
        event.stopPropagation();
        if (!disableEscapeKeyDown && handleClose) {
            handleClose(event, 'escapeKeyDown');
        }
    }, [disableEscapeKeyDown, handleClose]);
    const getScrollHandler = useCallback(() => {
        if (scrollHandler === 'wrapper')
            return wrapperRef.current;
        if (scrollHandler === 'content')
            return componentRef.current;
        return scrollHandler.current || wrapperRef.current;
    }, [scrollHandler]);
    const handleEntered = useCallback((node, isAppearing) => {
        scrollableNodeRef.current = getScrollHandler();
        addResizeHandle();
        if (scrollableNodeRef.current) {
            scrollableNodeRef.current.addEventListener('scroll', handleScroll);
            handleScroll();
        }
        if (transitionProps.onEntered) {
            transitionProps.onEntered(node, isAppearing);
        }
        if (onMount)
            onMount();
    }, [addResizeHandle, getScrollHandler, handleScroll, onMount, transitionProps]);
    const handleExited = useCallback(node => {
        removeResizeHandle();
        setExited(true);
        if (scrollableNodeRef.current) {
            scrollableNodeRef.current.removeEventListener('scroll', handleScroll);
        }
        if (transitionProps.onExited) {
            transitionProps.onExited(node);
        }
        if (onUnmount)
            onUnmount();
        if (restoreContainerStylesRef.current) {
            restoreContainerStylesRef.current();
        }
    }, [handleScroll, onUnmount, removeResizeHandle, transitionProps]);
    useEffect(() => {
        if (open) {
            handleContainer(getContainer());
            restoreContainerStylesRef.current = () => {
                restoreContainerStylesRef.current = null;
                restoreContainerStyles(getContainer());
            };
        }
    }, [getContainer, open]);
    useEffect(() => {
        if (open)
            setExited(false);
    }, [open]);
    useEffect(() => {
        return () => {
            if (restoreContainerStylesRef.current) {
                restoreContainerStylesRef.current();
            }
            resizeObserver.disconnect();
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const contextValue = useMemo(() => ({
        hasHeader,
        hasFooter,
        hasScroll,
        headerHighlighted,
        footerHighlighted,
        contentRef,
        setHasHeader,
        setHasFooter,
        onClose: handleClose,
    }), [
        contentRef,
        hasHeader,
        hasFooter,
        hasScroll,
        headerHighlighted,
        footerHighlighted,
        handleClose,
    ]);
    if (!shouldRender)
        return null;
    return (React.createElement(Stack, { value: zIndex }, computedZIndex => (React.createElement(Portal, { getPortalContainer: container },
        React.createElement(BaseModalContext.Provider, { value: contextValue },
            React.createElement(FocusLock, { autoFocus: !disableAutoFocus, disabled: disableFocusLock || !open, returnFocus: !disableRestoreFocus },
                Backdrop$1 && (React.createElement(Backdrop$1, Object.assign({}, backdropProps, { className: cn(backdropProps.className, styles.backdrop), open: open, style: {
                        zIndex: computedZIndex,
                    } }))),
                React.createElement("div", { role: 'dialog', className: cn(styles.wrapper, wrapperClassName, {
                        [styles.hidden]: !open && exited,
                    }), ref: mergeRefs([ref, wrapperRef]), onKeyDown: handleKeyDown, onClick: handleBackdropClick, tabIndex: -1, "data-test-id": dataTestId, style: {
                        zIndex: computedZIndex,
                    } },
                    React.createElement(CSSTransition, Object.assign({ appear: true, timeout: 200, classNames: styles }, transitionProps, { in: open, onEntered: handleEntered, onExited: handleExited }),
                        React.createElement("div", { className: cn(styles.component, className), ref: componentRef },
                            React.createElement("div", { className: cn(styles.content, contentClassName) }, children))))))))));
});

export { BaseModal, BaseModalContext };
