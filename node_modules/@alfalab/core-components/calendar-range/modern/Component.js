import React, { useState, useCallback } from 'react';
import cn from 'classnames';
import { startOfMonth, subMonths } from 'date-fns';
import { usePeriod, dateInLimits } from '../../calendar/modern';
import { parseDateString, isCompleteDateInput, formatDate, CalendarInput } from '../../calendar-input/modern';
import { initialValueState, getCorrectValueState, isDayButton } from './utils.js';
import { useCalendarMonthes } from './useCalendarMonthes.js';
import { useCalendarMaxMinDates } from './useCalendarMaxMinDates.js';

var styles = {"component":"calendar-range__component_ft44u","divider":"calendar-range__divider_ft44u"};
require('./index.css');

/* eslint-disable multiline-comment-style */
const CalendarRange = ({ className, defaultMonth = startOfMonth(new Date()).getTime(), minDate, maxDate, valueFrom, valueTo, onDateFromChange, onDateToChange, inputFromProps = {}, inputToProps = {}, calendarPosition = 'static', dataTestId, }) => {
    const uncontrolled = valueFrom === undefined && valueTo === undefined;
    const isPopover = calendarPosition === 'popover';
    const period = usePeriod({
        initialSelectedFrom: valueFrom ? parseDateString(valueFrom).getTime() : undefined,
        initialSelectedTo: valueTo ? parseDateString(valueTo).getTime() : undefined,
    });
    const { setStart, setEnd, resetPeriod } = period;
    let { selectedFrom, selectedTo } = period;
    if (!dateInLimits(selectedFrom, minDate, maxDate))
        selectedFrom = undefined;
    if (!dateInLimits(selectedTo, minDate, maxDate))
        selectedTo = undefined;
    const [stateFrom, setStateFrom] = useState(initialValueState);
    const [stateTo, setStateTo] = useState(initialValueState);
    const inputValueFrom = getCorrectValueState(stateFrom, valueFrom, minDate, maxDate);
    const inputValueTo = getCorrectValueState(stateTo, valueTo, minDate, maxDate);
    const handleStateFromChange = useCallback((newFromState) => {
        if (uncontrolled)
            setStateFrom(newFromState);
        if (onDateFromChange)
            onDateFromChange(newFromState);
    }, [onDateFromChange, uncontrolled]);
    const handleStateToChange = useCallback((newToState) => {
        if (uncontrolled)
            setStateTo(newToState);
        if (onDateToChange)
            onDateToChange(newToState);
    }, [onDateToChange, uncontrolled]);
    const { monthFrom, monthTo, handleMonthFromChange, handleMonthToChange } = useCalendarMonthes({
        inputValueFrom,
        inputValueTo,
        defaultMonth,
        isPopover,
    });
    const handleInputFromChange = useCallback((_, { value, date }) => {
        if (value === '') {
            setStart(undefined);
            handleStateFromChange(initialValueState);
        }
        if (!isCompleteDateInput(value)) {
            return;
        }
        if (dateInLimits(date, minDate, maxDate)) {
            setStart(date.getTime());
            handleMonthFromChange(startOfMonth(date).getTime());
            handleStateFromChange({ date: date.getTime(), value });
        }
        else {
            setStart(undefined);
            handleStateFromChange({ date: null, value });
        }
    }, [handleMonthFromChange, handleStateFromChange, maxDate, minDate, setStart]);
    const handleInputToChange = useCallback((_, { value, date }) => {
        if (value === '') {
            setEnd(undefined);
            handleStateToChange(initialValueState);
        }
        if (!isCompleteDateInput(value)) {
            return;
        }
        if (dateInLimits(date, minDate, maxDate)) {
            setEnd(date.getTime());
            handleMonthToChange(subMonths(startOfMonth(date), 1).getTime());
            handleStateToChange({ date: date.getTime(), value });
        }
        else {
            setEnd(undefined);
            handleStateToChange({ date: null, value });
        }
    }, [handleMonthToChange, handleStateToChange, maxDate, minDate, setEnd]);
    const handleCalendarChange = useCallback((date) => {
        if (!inputValueFrom.date) {
            setStart(date);
            handleStateFromChange({ date, value: formatDate(date) });
            return;
        }
        if (date < inputValueFrom.date) {
            resetPeriod();
            setStart(date);
            handleStateToChange(initialValueState);
            handleStateFromChange({ date, value: formatDate(date) });
            return;
        }
        if (date === inputValueFrom.date && date === inputValueTo.date) {
            resetPeriod();
            handleStateFromChange(initialValueState);
            handleStateToChange(initialValueState);
            return;
        }
        handleStateToChange({ date, value: formatDate(date) });
        setEnd(date);
    }, [
        inputValueFrom.date,
        inputValueTo.date,
        handleStateToChange,
        setEnd,
        setStart,
        handleStateFromChange,
        resetPeriod,
    ]);
    const handleFromCalendarChange = useCallback((date) => {
        if (!isPopover) {
            handleCalendarChange(date);
            return;
        }
        setStart(date);
        handleStateFromChange({ date, value: formatDate(date) });
    }, [handleCalendarChange, handleStateFromChange, isPopover, setStart]);
    const handleToCalendarChange = useCallback((date) => {
        if (!isPopover) {
            handleCalendarChange(date);
            return;
        }
        handleStateToChange({ date, value: formatDate(date) });
        setEnd(date);
    }, [handleCalendarChange, handleStateToChange, isPopover, setEnd]);
    const [nextMonthHighlighted, setNextMonthHighlighted] = useState(false);
    const handleCalendarToMouseOver = useCallback((event) => {
        const target = event.target;
        const dayHighlighted = isDayButton(target) || isDayButton(target.parentElement);
        if (nextMonthHighlighted && !dayHighlighted)
            setNextMonthHighlighted(false);
        if (!nextMonthHighlighted && dayHighlighted)
            setNextMonthHighlighted(true);
    }, [nextMonthHighlighted]);
    const selectorView = isPopover ? 'full' : 'month-only';
    const calendarSelectedTo = selectedTo || (nextMonthHighlighted ? monthTo : undefined);
    const maxMinDates = useCalendarMaxMinDates({
        isPopover,
        monthTo,
        monthFrom,
        selectedFrom,
        selectedTo: calendarSelectedTo,
        maxDate,
        minDate,
    });
    return (React.createElement("div", { className: cn(styles.component, className), "data-test-id": dataTestId },
        React.createElement(CalendarInput, Object.assign({}, inputFromProps, { useAnchorWidth: false, calendarPosition: calendarPosition, onInputChange: handleInputFromChange, onCalendarChange: handleFromCalendarChange, value: inputValueFrom.value, minDate: maxMinDates.fromMinDate, maxDate: maxMinDates.fromMaxDate, calendarProps: {
                ...inputFromProps.calendarProps,
                month: monthFrom,
                onMonthChange: handleMonthFromChange,
                selectorView,
                selectedFrom,
                selectedTo: calendarSelectedTo,
            } })),
        React.createElement("span", { className: styles.divider }),
        React.createElement("div", { onMouseOver: handleCalendarToMouseOver },
            React.createElement(CalendarInput, Object.assign({}, inputToProps, { useAnchorWidth: false, calendarPosition: calendarPosition, popoverPosition: 'bottom-end', onInputChange: handleInputToChange, onCalendarChange: handleToCalendarChange, value: inputValueTo.value, minDate: maxMinDates.toMinDate, maxDate: maxMinDates.toMaxDate, calendarProps: {
                    ...inputToProps.calendarProps,
                    month: monthTo,
                    onMonthChange: handleMonthToChange,
                    selectorView,
                    selectedFrom,
                    selectedTo,
                } })))));
};

export { CalendarRange };
