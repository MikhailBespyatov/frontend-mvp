import React, { forwardRef, useState, useRef, useCallback, useEffect } from 'react';
import cn from 'classnames';
import { useSwipeable } from 'react-swipeable';
import { BaseModal } from '../../base-modal/modern';
import { Typography } from '../../typography/modern';
import { Footer } from './components/footer/Component.js';
import '../../backdrop/modern';
import { SwipeableBackdrop } from './components/swipeable-backdrop/Component.js';

var styles = {"modal":"bottom-sheet__modal_1231f","component":"bottom-sheet__component_1231f","withTransition":"bottom-sheet__withTransition_1231f","marker":"bottom-sheet__marker_1231f","scrollableContainer":"bottom-sheet__scrollableContainer_1231f","withPadding":"bottom-sheet__withPadding_1231f","content":"bottom-sheet__content_1231f","title":"bottom-sheet__title_1231f","scrollLocked":"bottom-sheet__scrollLocked_1231f","appear":"bottom-sheet__appear_1231f","enter":"bottom-sheet__enter_1231f","appearActive":"bottom-sheet__appearActive_1231f","enterActive":"bottom-sheet__enterActive_1231f","enterDone":"bottom-sheet__enterDone_1231f","appearDone":"bottom-sheet__appearDone_1231f","exit":"bottom-sheet__exit_1231f","exitActive":"bottom-sheet__exitActive_1231f"};
require('./index.css');

const TIMEOUT = 300;
const SWIPE_CLOSE_VELOCITY = 0.4;
const MIN_BACKDROP_OPACITY = 0.2;
const CLOSE_OFFSET = 0.2;
const BottomSheet = forwardRef(({ open, title, actionButton, contentClassName, className, children, zIndex, transitionProps = {}, dataTestId, desktopSwipeable: trackMouse = false, onClose, }, ref) => {
    const [sheetOffset, setSheetOffset] = useState(0);
    const [backdropOpacity, setBackdropOpacity] = useState(1);
    const [scrollLocked, setScrollLocked] = useState(false);
    const sheetHeight = useRef(0);
    const scrollableContainer = useRef(null);
    const scrollableContainerScrollValue = useRef(0);
    const getBackdropOpacity = (offset) => {
        if (sheetHeight.current === 0)
            return MIN_BACKDROP_OPACITY;
        const opacity = 1 - (1 - MIN_BACKDROP_OPACITY) * (offset / sheetHeight.current);
        return Number(opacity.toFixed(2));
    };
    const getSheetOffset = (deltaY) => {
        let offset = deltaY > 0 ? 0 : -deltaY;
        offset -= scrollableContainerScrollValue.current;
        return Math.floor(Math.max(0, offset));
    };
    /**
     * Если контент внутри шторки скроллится - то шторка не должна свайпаться
     */
    const shouldSkipSwiping = () => {
        if (!scrollableContainer.current) {
            return false;
        }
        if (!scrollableContainerScrollValue.current) {
            scrollableContainerScrollValue.current = Math.floor(scrollableContainer.current.scrollTop);
        }
        return scrollableContainer.current.scrollTop > 0;
    };
    const handleBackdropSwipedDown = ({ velocity }) => {
        if (velocity > SWIPE_CLOSE_VELOCITY) {
            onClose();
        }
    };
    const handleSheetSwipedDown = ({ velocity }) => {
        if (shouldSkipSwiping()) {
            return;
        }
        const shouldClose = sheetOffset > sheetHeight.current * CLOSE_OFFSET || velocity > SWIPE_CLOSE_VELOCITY;
        if (shouldClose) {
            onClose();
        }
        else {
            setSheetOffset(0);
            setBackdropOpacity(1);
        }
    };
    const handleSheetSwiped = () => {
        setScrollLocked(false);
        scrollableContainerScrollValue.current = 0;
    };
    const handleSheetSwiping = ({ deltaY }) => {
        if (shouldSkipSwiping()) {
            return;
        }
        const offset = getSheetOffset(deltaY);
        const opacity = getBackdropOpacity(offset);
        setSheetOffset(offset);
        setBackdropOpacity(opacity);
        /**
         * Если шторка начинает свайпаться, то блокируем скролл внутри нее
         */
        if (offset > 0) {
            setScrollLocked(true);
        }
    };
    const backdropSwipeablehandlers = useSwipeable({
        onSwipedDown: handleBackdropSwipedDown,
        delta: 100,
        trackMouse,
    });
    const sheetSwipeablehandlers = useSwipeable({
        onSwiping: handleSheetSwiping,
        onSwipedDown: handleSheetSwipedDown,
        onSwiped: handleSheetSwiped,
        delta: 5,
        trackMouse,
    });
    const handleExited = useCallback(node => {
        setBackdropOpacity(1);
        if (transitionProps.onExited) {
            transitionProps.onExited(node);
        }
    }, [transitionProps]);
    const handleEntered = useCallback((node, isAppearing) => {
        if (!sheetHeight.current) {
            sheetHeight.current = node.getBoundingClientRect().height;
        }
        setBackdropOpacity(1);
        if (transitionProps.onEntered) {
            transitionProps.onEntered(node, isAppearing);
        }
    }, [transitionProps]);
    useEffect(() => {
        if (!open) {
            setSheetOffset(0);
        }
    }, [open]);
    const getSwipeStyles = () => ({
        transform: sheetOffset ? `translateY(${sheetOffset}px)` : '',
    });
    return (React.createElement(BaseModal, { open: open, ref: ref, dataTestId: dataTestId, zIndex: zIndex, onClose: onClose, scrollHandler: scrollableContainer, Backdrop: SwipeableBackdrop, backdropProps: {
            opacity: backdropOpacity,
            handlers: backdropSwipeablehandlers,
            opacityTimeout: TIMEOUT,
        }, className: styles.modal, transitionProps: {
            appear: true,
            timeout: TIMEOUT,
            classNames: styles,
            ...transitionProps,
            onExited: handleExited,
            onEntered: handleEntered,
        } },
        React.createElement("div", Object.assign({ className: cn(styles.component, className, {
                [styles.withTransition]: !sheetOffset,
            }), style: getSwipeStyles() }, sheetSwipeablehandlers),
            React.createElement("div", { className: styles.marker }),
            React.createElement("div", { className: cn(styles.scrollableContainer, {
                    [styles.scrollLocked]: scrollLocked,
                    [styles.withPadding]: !actionButton,
                }), ref: scrollableContainer },
                title && (React.createElement(Typography.Title, { view: 'small', font: 'system', tag: 'h2', className: styles.title, color: 'primary' }, title)),
                React.createElement("div", { className: cn(styles.content, contentClassName) }, children),
                actionButton && React.createElement(Footer, null, actionButton)))));
});

export { BottomSheet, CLOSE_OFFSET };
