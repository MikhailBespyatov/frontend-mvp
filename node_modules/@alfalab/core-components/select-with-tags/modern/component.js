import React, { forwardRef, useState, useRef, useCallback } from 'react';
import 'classnames';
import '@alfalab/hooks';
import '@alfalab/icons-glyph/CrossCompactMIcon';
import { OptionsList, Optgroup, Option, Arrow, BaseSelect } from '../../select/modern';
import '../../form-control/modern';
import '../../tag/modern';
import './components/tag/component.js';
import './utils/calculate-collapse-size.js';
import { TagList } from './components/tag-list/component.js';
import { filterOptions } from './utils/match.js';

const SelectWithTags = forwardRef(({ OptionsList: OptionsList$1 = OptionsList, Optgroup: Optgroup$1 = Optgroup, Option: Option$1 = Option, Arrow: Arrow$1 = Arrow, value, selected, size = 'xl', onInput, onChange, options, autocomplete = true, match, allowUnselect = true, collapseTagList = false, moveInputToNewLine = true, emptyListPlaceholder = 'Ничего не найдено.', transformCollapsedTagText, transformTagText, Tag, ...restProps }, ref) => {
    const controlled = Boolean(selected);
    const [selectedTags, setSelectedTags] = useState(selected || []);
    const [isPopoverOpen, setPopoverOpen] = useState(false);
    const updatePopover = useRef(() => null);
    const resetValue = useCallback(() => {
        const event = { target: { value: '' } };
        onInput(event);
    }, [onInput]);
    const handleUpdatePopover = useCallback(() => {
        if (updatePopover && updatePopover.current) {
            updatePopover.current();
        }
    }, []);
    const handleDeleteTag = useCallback((deletedKey) => {
        let tags = selected || selectedTags;
        tags = tags.filter(tag => {
            const key = typeof tag === 'string' ? tag : tag.key;
            return deletedKey !== key;
        });
        if (onChange) {
            onChange({ selectedMultiple: tags });
        }
        if (!controlled) {
            setSelectedTags(tags);
        }
    }, [controlled, onChange, selected, selectedTags]);
    const handleChange = useCallback(({ selectedMultiple, name }) => {
        if (onChange) {
            onChange({ selectedMultiple, name });
        }
        if (!controlled) {
            setSelectedTags(selectedMultiple);
        }
        if (value) {
            resetValue();
        }
    }, [onChange, controlled, value, resetValue]);
    const handleOpen = useCallback(({ open }) => {
        if (!open && value) {
            resetValue();
        }
        setPopoverOpen(open);
    }, [resetValue, value]);
    const filteredOptions = filterOptions(options, value, match);
    const isAutocomplete = autocomplete || Boolean(match);
    return (React.createElement(BaseSelect, Object.assign({}, restProps, { ref: ref, Option: Option$1, Field: TagList, Optgroup: Optgroup$1, OptionsList: OptionsList$1, Arrow: Arrow$1, multiple: true, updatePopover: updatePopover, allowUnselect: allowUnselect, showEmptyOptionsList: true, fieldProps: {
            value,
            autocomplete: isAutocomplete,
            onInput,
            handleDeleteTag,
            Tag,
            collapseTagList,
            moveInputToNewLine,
            transformCollapsedTagText,
            transformTagText,
            handleUpdatePopover,
            isPopoverOpen,
        }, optionsListProps: {
            emptyPlaceholder: emptyListPlaceholder,
        }, selected: selected || selectedTags, autocomplete: isAutocomplete, size: size, options: filteredOptions, onChange: handleChange, onOpen: handleOpen })));
});

export { SelectWithTags };
