Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('../../tslib.es6-ce870b46.js');
var React = require('react');
var cn = require('classnames');
var hooks = require('@alfalab/hooks');
var coreComponentsFormControl = require('../../../../form-control/cssm');
require('../../../../tag/cssm');
require('@alfalab/icons-glyph/CrossCompactMIcon');
require('../tag/index.module.css');
var components_tag_component = require('../tag/component.js');
var utils_calculateCollapseSize = require('../../utils/calculate-collapse-size.js');
var styles = require('./index.module.css');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var cn__default = /*#__PURE__*/_interopDefaultLegacy(cn);
var styles__default = /*#__PURE__*/_interopDefaultLegacy(styles);

var TagList = function (_a) {
    var _b, _c, _d;
    var _e = _a.size, size = _e === void 0 ? 'xl' : _e, open = _a.open, disabled = _a.disabled, placeholder = _a.placeholder, _f = _a.selectedMultiple, selectedMultiple = _f === void 0 ? [] : _f, Arrow = _a.Arrow, innerProps = _a.innerProps, className = _a.className, fieldClassName = _a.fieldClassName, _g = _a.value, value = _g === void 0 ? '' : _g, autocomplete = _a.autocomplete, label = _a.label, valueRenderer = _a.valueRenderer, onInput = _a.onInput, handleDeleteTag = _a.handleDeleteTag, collapseTagList = _a.collapseTagList, moveInputToNewLine = _a.moveInputToNewLine, transformCollapsedTagText = _a.transformCollapsedTagText, transformTagText = _a.transformTagText, isPopoverOpen = _a.isPopoverOpen, handleUpdatePopover = _a.handleUpdatePopover, _h = _a.Tag, Tag = _h === void 0 ? components_tag_component.Tag : _h, restProps = tslib_es6.__rest(_a, ["size", "open", "disabled", "placeholder", "selectedMultiple", "Arrow", "innerProps", "className", "fieldClassName", "value", "autocomplete", "label", "valueRenderer", "onInput", "handleDeleteTag", "collapseTagList", "moveInputToNewLine", "transformCollapsedTagText", "transformTagText", "isPopoverOpen", "handleUpdatePopover", "Tag"]);
    var _j = React.useState(false), focused = _j[0], setFocused = _j[1];
    var _k = React.useState(false), isShowMoreEnabled = _k[0], setShowMoreEnabled = _k[1];
    var _l = React.useState(1), visibleElements = _l[0], setVisibleElements = _l[1];
    var _m = React.useState(false), inputOnNewLine = _m[0], setInputOnNewLine = _m[1];
    var wrapperRef = React.useRef(null);
    var inputRef = React.useRef(null);
    var contentWrapperRef = React.useRef(null);
    var focusVisible = hooks.useFocus(wrapperRef, 'keyboard')[0];
    var inputFocusVisible = hooks.useFocus(inputRef, 'keyboard')[0];
    React.useLayoutEffect(function () {
        setShowMoreEnabled(isPopoverOpen);
    }, [isPopoverOpen]);
    React.useLayoutEffect(function () {
        setVisibleElements(selectedMultiple.length);
        setShowMoreEnabled(false);
    }, [selectedMultiple]);
    React.useLayoutEffect(function () {
        if (collapseTagList && contentWrapperRef.current) {
            var totalVisibleElements = utils_calculateCollapseSize.calculateTotalElementsPerRow(contentWrapperRef.current, autocomplete && inputRef.current ? inputRef.current : null);
            setVisibleElements(totalVisibleElements);
        }
    }, [collapseTagList, visibleElements, autocomplete]);
    var handleFocus = React.useCallback(function () { return setFocused(true); }, []);
    var handleBlur = React.useCallback(function () { return setFocused(false); }, []);
    var inputTextIsOverflow = React.useCallback(function () { return inputRef.current && inputRef.current.scrollWidth > inputRef.current.clientWidth; }, []);
    var handleMouseDown = React.useCallback(function (event) {
        event.preventDefault();
    }, []);
    var onClick = innerProps.onClick, restInnerProps = tslib_es6.__rest(innerProps, ["onClick"]);
    var handleClick = React.useCallback(function (event) {
        if (onClick && contentWrapperRef.current) {
            var eventTarget = event.target;
            var clickedInsideContent = eventTarget !== contentWrapperRef.current &&
                contentWrapperRef.current.contains(eventTarget);
            if (!clickedInsideContent) {
                onClick(event);
            }
        }
        if (inputRef.current) {
            inputRef.current.focus();
        }
    }, [onClick]);
    var handleKeyDown = React.useCallback(function (event) {
        var lastSelectedTag = selectedMultiple[selectedMultiple.length - 1];
        if (event.key === 'Backspace' && !value && handleDeleteTag && lastSelectedTag) {
            handleDeleteTag(lastSelectedTag.key);
        }
    }, [handleDeleteTag, selectedMultiple, value]);
    var toggleShowMoreLessButton = React.useCallback(function (event) {
        event.stopPropagation();
        setShowMoreEnabled(function (v) { return !v; });
        if (handleUpdatePopover) {
            handleUpdatePopover();
        }
    }, [handleUpdatePopover]);
    React.useEffect(function () {
        /**
         * Если текст не помещается в инпут, то нужно перенести инпут на новую строку.
         */
        if (moveInputToNewLine) {
            if (inputTextIsOverflow() && !inputOnNewLine) {
                setInputOnNewLine(true);
            }
            else if (value.length === 0) {
                setInputOnNewLine(false);
            }
        }
    }, [value, inputOnNewLine, inputTextIsOverflow, moveInputToNewLine]);
    var collapseTagTitle = React.useMemo(function () {
        if (isShowMoreEnabled) {
            return 'Свернуть';
        }
        if (transformCollapsedTagText) {
            return transformCollapsedTagText(selectedMultiple.length - visibleElements);
        }
        return "+" + (selectedMultiple.length - visibleElements);
    }, [transformCollapsedTagText, isShowMoreEnabled, selectedMultiple.length, visibleElements]);
    var filled = Boolean(selectedMultiple.length > 0) || Boolean(value);
    /**
     * Флаг который позволит добавлять класс с вертикальными
     * отступами если элементы не помещаются в один ряд,
     * для того чтобы не менялась высота инпута
     */
    var shouldAddVerticalMargin = Boolean((!collapseTagList || isShowMoreEnabled) && !label);
    return (React__default['default'].createElement("div", { ref: wrapperRef, onFocus: handleFocus, onBlur: handleBlur, className: cn__default['default'](className, styles__default['default'].component, styles__default['default'][size]) },
        React__default['default'].createElement(coreComponentsFormControl.FormControl, tslib_es6.__assign({}, restProps, { ref: innerProps.ref, fieldClassName: cn__default['default'](fieldClassName, styles__default['default'].field, (_b = {},
                _b[styles__default['default'].focusVisible] = focusVisible,
                _b)), block: true, size: size, focused: open || focused, disabled: disabled, filled: filled || !!placeholder, onMouseDown: handleMouseDown, rightAddons: Arrow, onClick: handleClick, addonsClassName: cn__default['default'](styles__default['default'].addons, styles__default['default']["addons-size-" + size]), label: label, labelClassName: styles__default['default'].label }),
            React__default['default'].createElement("div", { className: cn__default['default'](styles__default['default'].contentWrapper, (_c = {},
                    _c[styles__default['default'].hasLabel] = Boolean(label),
                    _c[styles__default['default'].hasTags] = selectedMultiple.length > 0,
                    _c[styles__default['default'].contentWrapperVertical] = shouldAddVerticalMargin,
                    _c)), ref: contentWrapperRef },
                selectedMultiple.map(function (option, index) {
                    return isShowMoreEnabled || index + 1 <= visibleElements ? (React__default['default'].createElement(Tag, { option: tslib_es6.__assign(tslib_es6.__assign({}, option), { content: transformTagText
                                ? transformTagText(option.content)
                                : option.content }), key: option.key, handleDeleteTag: handleDeleteTag })) : null;
                }),
                visibleElements < selectedMultiple.length && (React__default['default'].createElement(Tag, { "data-collapse": 'collapse-last-tag-element', onClick: toggleShowMoreLessButton, option: {
                        key: 'collapse',
                        content: collapseTagTitle,
                    } })),
                autocomplete && (React__default['default'].createElement("input", tslib_es6.__assign({}, restInnerProps, { autoComplete: 'off', ref: inputRef, value: value, onChange: onInput, className: cn__default['default'](styles__default['default'].input, (_d = {},
                        _d[styles__default['default'].focusVisible] = inputFocusVisible,
                        _d[styles__default['default'].block] = inputOnNewLine,
                        _d)), disabled: disabled, onKeyDown: handleKeyDown, placeholder: filled ? '' : placeholder }))),
                placeholder && !filled && !autocomplete && (React__default['default'].createElement("span", { className: styles__default['default'].placeholder }, placeholder))))));
};

exports.TagList = TagList;
