import React, { useRef, useState, useCallback, Fragment } from 'react';
import cn from 'classnames';
import mergeRefs from 'react-merge-refs';
import { useFocus } from '@alfalab/hooks';
import { CrossCircleMIcon } from '@alfalab/icons-glyph/CrossCircleMIcon';
import { Button } from '../../button/modern';
import { FormControl } from '../../form-control/modern';

var styles = {"input":"input__input_12t1g","hasLabel":"input__hasLabel_12t1g","block":"input__block_12t1g","clearIcon":"input__clearIcon_12t1g","errorIcon":"input__errorIcon_12t1g","clearButton":"input__clearButton_12t1g","successIcon":"input__successIcon_12t1g","focusVisible":"input__focusVisible_12t1g","onautofillstart":"input__onautofillstart_12t1g","onautofillcancel":"input__onautofillcancel_12t1g"};
require('./index.css');

var defaultColors = {"input":"input__input_wvq7f","hasLabel":"input__hasLabel_wvq7f","clearIcon":"input__clearIcon_wvq7f","errorIcon":"input__errorIcon_wvq7f","successIcon":"input__successIcon_wvq7f","error":"input__error_wvq7f"};
require('./default.css');

var invertedColors = {"input":"input__input_zvutf","hasLabel":"input__hasLabel_zvutf","clearIcon":"input__clearIcon_zvutf","errorIcon":"input__errorIcon_zvutf","successIcon":"input__successIcon_zvutf","error":"input__error_zvutf"};
require('./inverted.css');

const colorStyles = {
    default: defaultColors,
    inverted: invertedColors,
};
const Input = React.forwardRef(({ size = 's', type = 'text', block = false, colors = 'default', bottomAddons, dataTestId, clear = false, disabled, error, success, hint, className, fieldClassName, inputClassName, labelClassName, addonsClassName, focusedClassName, filledClassName, label, leftAddons, onFocus, onBlur, onChange, onClear, onClick, onMouseDown, onMouseUp, onAnimationStart, rightAddons, value, defaultValue, wrapperRef, readOnly, ...restProps }, ref) => {
    const uncontrolled = value === undefined;
    const inputRef = useRef(null);
    const [focusVisible] = useFocus(inputRef, 'keyboard');
    const [focused, setFocused] = useState(restProps.autoFocus);
    const [stateValue, setStateValue] = useState(defaultValue || '');
    const filled = Boolean(uncontrolled ? stateValue : value);
    const [autofilled, setAutofilled] = useState(false);
    // отображаем крестик только для заполненного и активного инпута
    const clearButtonVisible = clear && filled && !disabled && !readOnly;
    const handleInputFocus = useCallback((event) => {
        if (!readOnly) {
            setFocused(true);
        }
        if (onFocus) {
            onFocus(event);
        }
    }, [onFocus, readOnly]);
    const handleInputBlur = useCallback((event) => {
        setFocused(false);
        if (onBlur) {
            onBlur(event);
        }
    }, [onBlur]);
    const handleInputChange = useCallback((event) => {
        if (onChange) {
            onChange(event, { value: event.target.value });
        }
        if (uncontrolled) {
            setStateValue(event.target.value);
        }
    }, [onChange, uncontrolled]);
    const handleClear = useCallback((event) => {
        if (!clearButtonVisible)
            return;
        if (uncontrolled) {
            setStateValue('');
        }
        if (onClear) {
            onClear(event);
        }
        if (inputRef.current && !focused) {
            inputRef.current.focus();
        }
    }, [clearButtonVisible, focused, onClear, uncontrolled]);
    const handleAnimationStart = useCallback((event) => {
        if (onAnimationStart) {
            onAnimationStart(event);
        }
        setAutofilled(event.animationName.includes('start'));
    }, [onAnimationStart]);
    const renderRightAddons = () => {
        const addonsVisible = clearButtonVisible || rightAddons || error || success;
        return (addonsVisible && (React.createElement(Fragment, null,
            clearButtonVisible && (React.createElement(Button, { type: 'button', view: 'ghost', disabled: disabled, "aria-label": '\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C', className: styles.clearButton, onClick: handleClear },
                React.createElement(CrossCircleMIcon, { className: cn(styles.clearIcon, colorStyles[colors].clearIcon) }))),
            rightAddons,
            error && (React.createElement("span", { className: cn(styles.errorIcon, colorStyles[colors].errorIcon) })),
            success && !error && (React.createElement("span", { className: cn(styles.successIcon, colorStyles[colors].successIcon) })))));
    };
    return (React.createElement(FormControl, { ref: wrapperRef, className: cn(className, focused && focusedClassName, filled && filledClassName), fieldClassName: cn(fieldClassName, {
            [styles.focusVisible]: focusVisible,
        }), labelClassName: labelClassName, addonsClassName: addonsClassName, size: size, colors: colors, block: block, disabled: disabled, filled: filled || autofilled || focused, focused: focused, error: error, label: label, hint: hint, leftAddons: leftAddons, rightAddons: renderRightAddons(), bottomAddons: bottomAddons, onClick: onClick, onMouseDown: onMouseDown, onMouseUp: onMouseUp },
        React.createElement("input", Object.assign({}, restProps, { className: cn(styles.input, colorStyles[colors].input, {
                [styles.error]: error,
                [colorStyles[colors].error]: error,
                [styles.hasLabel]: label,
                [colorStyles[colors].hasLabel]: label,
            }, inputClassName), disabled: disabled, onBlur: handleInputBlur, onFocus: handleInputFocus, onChange: handleInputChange, onAnimationStart: handleAnimationStart, ref: mergeRefs([ref, inputRef]), type: type, value: uncontrolled ? stateValue : value, readOnly: readOnly, "data-test-id": dataTestId, "aria-label": typeof label === 'string' ? label : undefined }))));
});
/**
 * Для отображения в сторибуке
 */
Input.defaultProps = {
    size: 's',
    type: 'text',
    block: false,
};

export { Input };
