import React, { useRef, useState, useEffect, useMemo } from 'react';
import cn from 'classnames';
import { useVirtual } from 'react-virtual';
import { usePrevious, lastIndexOf, useVisibleOptions, isGroup } from '../../utils.js';
import { Optgroup } from '../optgroup/Component.js';

var styles = {"virtualOptionsList":"select__virtualOptionsList_18pc2","scrollable":"select__scrollable_18pc2","inner":"select__inner_18pc2","virtualRow":"select__virtualRow_18pc2","highlighted":"select__highlighted_18pc2","emptyPlaceholder":"select__emptyPlaceholder_18pc2","l":"select__l_18pc2","xl":"select__xl_18pc2"};
require('./index.css');

/* eslint-disable react-hooks/exhaustive-deps */
const VirtualOptionsList = ({ size = 's', flatOptions = [], highlightedIndex = -1, className, getOptionProps, Option, open, options = [], overscan = 10, Optgroup: Optgroup$1 = Optgroup, dataTestId, emptyPlaceholder, visibleOptions = 5, onScroll, header, footer, }) => {
    const listRef = useRef(null);
    const parentRef = useRef(null);
    const [visibleOptionsInvalidateKey, setVisibleOptionsInvalidateKey] = useState(0);
    const prevHighlightedIndex = usePrevious(highlightedIndex) || -1;
    const rowVirtualizer = useVirtual({
        size: flatOptions.length,
        parentRef,
        overscan,
    });
    // Сколл к выбранному пункту при открытии меню
    useEffect(() => {
        if (open) {
            rowVirtualizer.scrollToIndex(highlightedIndex, { align: 'end' });
        }
    }, [open]);
    // Скролл к пункту, которого нет на экране
    useEffect(() => {
        if (highlightedIndex === -1)
            return;
        if (!rowVirtualizer.virtualItems.some(option => option.index === highlightedIndex)) {
            rowVirtualizer.scrollToIndex(highlightedIndex, { align: 'end' });
        }
    }, [highlightedIndex]);
    // Циклическая навигация
    useEffect(() => {
        const notDisabled = (option) => !option.disabled;
        const firstNonDisabled = flatOptions.findIndex(notDisabled);
        const lastNonDisabled = lastIndexOf(flatOptions, notDisabled);
        if (prevHighlightedIndex <= firstNonDisabled &&
            highlightedIndex === flatOptions.length - 1) {
            rowVirtualizer.scrollToIndex(lastNonDisabled);
        }
        if (prevHighlightedIndex >= lastNonDisabled && highlightedIndex === 0) {
            rowVirtualizer.scrollToIndex(0);
        }
    }, [prevHighlightedIndex, highlightedIndex]);
    useEffect(() => {
        setVisibleOptionsInvalidateKey(
        /**
         * react-virtual может несколько раз отрендерить список с одним элементом,
         * поэтому нужно еще раз пересчитать высоту, когда список ВИДИМЫХ пунктов будет отрендерен полностью
         * Также, высоту нужно пересчитывать при изменении ОБЩЕГО кол-ва пунктов меню
         */
        rowVirtualizer.virtualItems.length > 1 ? flatOptions.length : 1);
    }, [rowVirtualizer.virtualItems.length, flatOptions.length]);
    useVisibleOptions({
        visibleOptions,
        invalidate: visibleOptionsInvalidateKey,
        listRef,
        styleTargetRef: parentRef,
        open,
    });
    // Т.к. рендерится плоский список, необходимо знать индекс, когда начинается новая группа
    const groupStartIndexes = useMemo(() => {
        let currentIndex = 0;
        return options.reduce((acc, option, index) => {
            if (isGroup(option)) {
                acc[currentIndex] = index;
                currentIndex += option.options.length;
            }
            else {
                currentIndex += 1;
            }
            return acc;
        }, {});
    }, [options]);
    return (React.createElement("div", { className: cn(styles.virtualOptionsList, styles[size], className), "data-test-id": dataTestId },
        header,
        React.createElement("div", { className: styles.scrollable, ref: parentRef, onScroll: onScroll },
            React.createElement("div", { className: styles.inner, style: {
                    height: `${rowVirtualizer.totalSize}px`,
                }, ref: listRef }, rowVirtualizer.virtualItems.map(virtualRow => {
                const option = flatOptions[virtualRow.index];
                const group = options[groupStartIndexes[virtualRow.index]];
                return (React.createElement("div", { key: virtualRow.index, ref: virtualRow.measureRef, className: cn(styles.virtualRow, {
                        [styles.highlighted]: highlightedIndex === virtualRow.index,
                    }), style: {
                        transform: `translateY(${virtualRow.start}px)`,
                    } },
                    group && React.createElement(Optgroup$1, { label: group.label }),
                    !isGroup(option) && (React.createElement(Option, Object.assign({}, getOptionProps(option, virtualRow.index))))));
            }))),
        emptyPlaceholder && options.length === 0 && (React.createElement("div", { className: styles.emptyPlaceholder }, emptyPlaceholder)),
        footer));
};

export { VirtualOptionsList };
