import { isValidElement, cloneElement, useEffect, useRef } from 'react';

const isGroup = (item) => Object.prototype.hasOwnProperty.call(item, 'options');
const isOptionShape = (item) => !!item && Object.prototype.hasOwnProperty.call(item, 'key');
const joinOptions = ({ selected, selectedMultiple, }) => {
    const options = selectedMultiple || (selected ? [selected] : []);
    if (!options.length)
        return null;
    return options.reduce((acc, option, index) => {
        if (isValidElement(option.content)) {
            acc.push(cloneElement(option.content, { key: option.key }));
        }
        else {
            acc.push(option.content);
        }
        if (index < options.length - 1)
            acc.push(', ');
        return acc;
    }, []);
};
// За один проход делает список пунктов меню плоским и находит выбранные пункты по ключу
function processOptions(options, selected = []) {
    const flatOptions = [];
    const selectedArray = Array.isArray(selected) ? selected : [selected];
    const selectedOptions = selectedArray.filter(isOptionShape);
    const selectedKeys = selectedArray.filter((option) => typeof option === 'string');
    const isSelected = (option) => selectedKeys.includes(option.key);
    const process = (option) => {
        flatOptions.push(option);
        if (isSelected(option)) {
            selectedOptions.push(option);
        }
    };
    options.forEach(option => {
        if (isGroup(option)) {
            option.options.forEach(process);
        }
        else {
            process(option);
        }
    });
    return { flatOptions, selectedOptions };
}
function useVisibleOptions({ visibleOptions, listRef, styleTargetRef = listRef, open, invalidate, }) {
    useEffect(() => {
        const list = listRef.current;
        const styleTarget = styleTargetRef.current;
        if (open && list && styleTarget) {
            const optionsNodes = [].slice.call(list.children, 0, visibleOptions + 1);
            let height = optionsNodes
                .slice(0, visibleOptions)
                .reduce((acc, child) => acc + child.clientHeight, 0);
            if (visibleOptions < list.children.length) {
                // Добавляем половинку
                height += Math.round(optionsNodes[optionsNodes.length - 1].clientHeight / 2);
            }
            styleTarget.style.height = `${height}px`;
        }
    }, [listRef, open, styleTargetRef, visibleOptions, invalidate]);
}
// TODO: перенести
function usePrevious(value) {
    const ref = useRef();
    useEffect(() => {
        ref.current = value;
    }, [value]);
    return ref.current;
}
// TODO: перенести
const lastIndexOf = (array, predicate) => {
    for (let i = array.length - 1; i >= 0; i--) {
        if (predicate(array[i]))
            return i;
    }
    return -1;
};

export { isGroup, isOptionShape, joinOptions, lastIndexOf, processOptions, usePrevious, useVisibleOptions };
