import React, { forwardRef, useRef, useCallback, useEffect, useMemo, useState } from 'react';
import cn from 'classnames';
import '@alfalab/hooks';
import '@alfalab/icons-glyph/ChevronDownMIcon';
import 'react-merge-refs';
import 'resize-observer';
import 'downshift';
import 'react-virtual';
import '../../form-control/modern';
import { processOptions } from './utils.js';
import './components/field/Component.js';
import './components/arrow/Component.js';
import './components/optgroup/Component.js';
import { OptionsList } from './components/options-list/Component.js';
import '../../checkbox/modern';
import './components/checkmark/Component.js';
import './components/option/Component.js';
import '../../popover/modern';
import './components/native-select/Component.js';
import './components/base-select/Component.js';
import './Component.js';
import '../../skeleton/modern';
import './intersection-observer-de5aa0a1.js';
import { Button } from '../../button/modern';

var styles = {"footer":"select__footer_18ac7","withBorder":"select__withBorder_18ac7"};
require('./presets/useSelectWithApply/options-list-with-apply/index.css');

const OptionsListWithApply = forwardRef(({ toggleMenu, OptionsList: OptionsList$1 = OptionsList, getOptionProps: defaultGetOptionProps, showClear = true, selectedDraft = [], flatOptions = [], onApply = () => null, onClear = () => null, onClose = () => null, visibleOptions = 5, ...restProps }, ref) => {
    const footerRef = useRef(null);
    const getOptionProps = useCallback((option, index) => {
        const optionProps = defaultGetOptionProps(option, index);
        const selected = option.key === SELECT_ALL_KEY
            ? selectedDraft.length === flatOptions.length - 1
            : selectedDraft.includes(option);
        return {
            ...optionProps,
            selected,
        };
    }, [defaultGetOptionProps, flatOptions.length, selectedDraft]);
    const handleApply = useCallback(() => {
        onApply();
        toggleMenu();
    }, [onApply, toggleMenu]);
    const handleClear = useCallback(() => {
        onClear();
        toggleMenu();
    }, [onClear, toggleMenu]);
    useEffect(() => {
        const activeElement = document.activeElement;
        setTimeout(() => {
            if (footerRef.current) {
                footerRef.current.focus();
            }
        }, 0);
        return () => {
            onClose();
            if (activeElement) {
                activeElement.focus();
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return (React.createElement(OptionsList$1, Object.assign({}, restProps, { ref: ref, visibleOptions: visibleOptions, toggleMenu: toggleMenu, flatOptions: flatOptions, getOptionProps: getOptionProps, footer: React.createElement("div", { 
            // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
            tabIndex: 0, className: cn(styles.footer, {
                [styles.withBorder]: visibleOptions && flatOptions.length > visibleOptions,
            }), ref: footerRef },
            React.createElement(Button, { size: 'xxs', view: 'primary', onClick: handleApply }, "\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C"),
            showClear && (React.createElement(Button, { size: 'xxs', view: 'secondary', onClick: handleClear }, "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C"))) })));
});

const SELECT_ALL_KEY = 'select_all';
const selectAllOption = { key: SELECT_ALL_KEY, content: 'Выбрать все' };
function useSelectWithApply({ options, selected, onChange = () => null, OptionsList, showClear = true, showSelectAll = false, }) {
    const { flatOptions, selectedOptions } = useMemo(() => processOptions(options, selected), [
        options,
        selected,
    ]);
    const [selectedDraft, setSelectedDraft] = useState(selectedOptions);
    const selectedOptionsRef = useRef(selectedOptions);
    const handleApply = useCallback(() => {
        onChange({
            selected: selectedDraft[0],
            selectedMultiple: selectedDraft,
            initiator: null,
        });
    }, [onChange, selectedDraft]);
    const handleClear = useCallback(() => {
        setSelectedDraft([]);
        onChange({
            selected: null,
            selectedMultiple: [],
            initiator: null,
        });
    }, [onChange]);
    const handleChange = useCallback(({ initiator, ...restArgs }) => {
        if (!initiator) {
            onChange({
                initiator: null,
                ...restArgs,
            });
            return;
        }
        const initiatorSelected = selectedDraft.includes(initiator) ||
            (initiator.key === SELECT_ALL_KEY && selectedDraft.length === flatOptions.length);
        if (initiator.key === SELECT_ALL_KEY) {
            setSelectedDraft(initiatorSelected ? [] : flatOptions);
        }
        else {
            setSelectedDraft(initiatorSelected
                ? selectedDraft.filter(o => o !== initiator)
                : selectedDraft.concat(initiator));
        }
    }, [flatOptions, onChange, selectedDraft]);
    const handleClose = useCallback(() => {
        setSelectedDraft(selectedOptionsRef.current);
    }, []);
    useEffect(() => {
        setSelectedDraft(selectedOptions);
        selectedOptionsRef.current = selectedOptions;
    }, [selectedOptions]);
    const memoizedOptions = useMemo(() => (showSelectAll ? [selectAllOption, ...options] : options), [options, showSelectAll]);
    return {
        OptionsList: OptionsListWithApply,
        optionsListProps: {
            OptionsList,
            showClear: showClear && (selectedDraft.length > 0 || selectedOptions.length > 0),
            onClear: handleClear,
            onApply: handleApply,
            onClose: handleClose,
            selectedDraft,
        },
        allowUnselect: true,
        multiple: true,
        options: memoizedOptions,
        onChange: handleChange,
        selected,
    };
}

export { OptionsListWithApply as O, SELECT_ALL_KEY as S, useSelectWithApply as u };
