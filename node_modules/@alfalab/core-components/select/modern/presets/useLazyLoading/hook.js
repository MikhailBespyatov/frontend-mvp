import React, { useReducer, useRef, useCallback, useEffect, useMemo } from 'react';
import 'classnames';
import '../../../../checkbox/modern';
import '../../components/checkmark/Component.js';
import { Option } from '../../components/option/Component.js';
import { Skeleton } from '../../../../skeleton/modern';
import '../../intersection-observer-de5aa0a1.js';

var styles = {"skeleton":"select__skeleton_1a0z0"};
require('./index.css');

const DEBOUNCE_TIMEOUT = 300;
const actions = {
    fetchOptionsStart() {
        return { type: 'FETCH_OPTIONS_START' };
    },
    fetchOptionsBreak() {
        return { type: 'FETCH_OPTIONS_BREAK' };
    },
    fetchOptionsSuccess(payload) {
        return { type: 'FETCH_OPTIONS_SUCCESS', payload };
    },
    setIsOpened(opened) {
        return { type: 'SET_IS_OPENED', payload: opened };
    },
    setQueryString(qs) {
        return { type: 'SET_QUERY_STRING', payload: qs };
    },
    reset() {
        return { type: 'RESET' };
    },
};
function useLazyLoading({ limit = 10, initialOffset = 0, optionsFetcher, skeleton = React.createElement(Skeleton, { className: styles.skeleton, visible: true }), }) {
    const initialOptions = [];
    const initialLoading = false;
    const lazyLoadingInitialState = {
        opened: false,
        offset: initialOffset,
        options: initialOptions,
        loading: initialLoading,
        allOptionsLoaded: false,
        queryString: '',
    };
    const lazyLoadingReducer = (state, action) => {
        switch (action.type) {
            case 'FETCH_OPTIONS_START': {
                return {
                    ...state,
                    loading: true,
                };
            }
            case 'FETCH_OPTIONS_BREAK': {
                return {
                    ...state,
                    loading: false,
                };
            }
            case 'FETCH_OPTIONS_SUCCESS': {
                return {
                    ...state,
                    options: [...state.options, ...action.payload.options],
                    offset: state.offset + (action.payload.options.length ? 1 : 0),
                    allOptionsLoaded: !action.payload.hasMore,
                    loading: false,
                };
            }
            case 'SET_IS_OPENED': {
                return {
                    ...state,
                    opened: action.payload,
                };
            }
            case 'SET_QUERY_STRING': {
                return {
                    // Изменение queryString подразумевает сброс текущих опций.
                    ...lazyLoadingInitialState,
                    opened: state.opened,
                    loading: true,
                    queryString: action.payload,
                };
            }
            case 'RESET': {
                return {
                    ...lazyLoadingInitialState,
                };
            }
            default: {
                return state;
            }
        }
    };
    const [{ opened, offset, options, loading, allOptionsLoaded, queryString }, dispatch,] = useReducer(lazyLoadingReducer, lazyLoadingInitialState);
    const abortFetchingOptionsRef = useRef();
    const fetchNextOffsetOptions = useCallback(() => {
        dispatch(actions.fetchOptionsStart());
        new Promise((resolve, reject) => {
            // eslint-disable-next-line no-unused-expressions
            abortFetchingOptionsRef.current?.();
            abortFetchingOptionsRef.current = reject;
            optionsFetcher(offset, limit, queryString).then(res => {
                resolve(res);
            });
        })
            .then(res => {
            dispatch(actions.fetchOptionsSuccess(res));
            abortFetchingOptionsRef.current = undefined;
        })
            .catch(
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        () => { });
    }, [optionsFetcher, offset, limit, queryString]);
    const listRef = useRef(null);
    useEffect(() => {
        let observer;
        if (opened && !loading && !allOptionsLoaded) {
            observer = new IntersectionObserver(([entry]) => {
                if (entry.isIntersecting) {
                    if (observer) {
                        observer.disconnect();
                    }
                    fetchNextOffsetOptions();
                }
            }, {
                root: listRef.current,
            });
            /*
             * Обсервим пересечение последней опции с контейнером.
             * Таким образом, загрузка следующей "страницы" начнется когда юзер доскроллит список
             * до верхнего края последней опции, что обеспечивает плавность
             */
            const options = listRef.current?.querySelectorAll('[role="option"]');
            const lastOption = options?.[options.length - 1];
            if (lastOption) {
                observer.observe(lastOption);
            }
        }
        return () => {
            if (observer) {
                observer.disconnect();
            }
        };
    }, [offset, fetchNextOffsetOptions, opened, allOptionsLoaded, initialOffset, loading]);
    const onOpen = useCallback((payload) => {
        if (payload.open) {
            if (options.length === initialOptions.length) {
                fetchNextOffsetOptions();
            }
        }
        else {
            // eslint-disable-next-line no-unused-expressions
            abortFetchingOptionsRef.current?.();
            dispatch(actions.fetchOptionsBreak());
        }
        dispatch(actions.setIsOpened(payload.open ?? false));
    }, [initialOptions.length, fetchNextOffsetOptions, options.length]);
    const fetchNextOptionsRef = useRef();
    const fetchNextOptionsTimerRef = useRef();
    useEffect(() => {
        fetchNextOptionsRef.current = fetchNextOffsetOptions;
    }, [fetchNextOffsetOptions]);
    const onQueryStringChange = useCallback((_, payload) => {
        dispatch(actions.setQueryString(payload.value));
        /* eslint-disable no-unused-expressions */
        /*
         * Если во время загрузки опций юзер ввел новый текст в инпут,
         * нужно прервать текущую загрузку, чтобы неактуальные опции не попали в выдачу
         */
        abortFetchingOptionsRef.current?.();
        listRef.current?.scrollTo({ top: 0 });
        /* Дебаунсим ввод текста, чтобы не отправлять запрос к новым опциям на каждый чих */
        if (fetchNextOptionsTimerRef.current) {
            clearTimeout(fetchNextOptionsTimerRef.current);
        }
        fetchNextOptionsTimerRef.current = setTimeout(() => {
            /*
             * После дебаунса необходимо вызвать функцию-загрузчик,
             * содержащую актуальные на данный момент данные оффсета и queryString.
             * Поэтому мы не можем обратиться напрямую к функции fetchNextOptions,
             * так как она будет замкнута на старые значения, актуальные на момент вызова хэндлера,
             * так что берем ее из обновляемого рефа
             */
            fetchNextOptionsRef.current?.();
        }, DEBOUNCE_TIMEOUT);
        /* eslint-enable */
    }, []);
    const renderOption = useCallback(props => React.createElement(Option, Object.assign({}, props, { highlighted: loading ? false : props.highlighted })), [loading]);
    const skeletonOptions = useMemo(() => {
        return Array(loading ? limit : 0)
            .fill(0)
            .map((_, key) => ({
            key: `loading-${key}`,
            disabled: true,
            content: skeleton,
        }));
    }, [loading, limit, skeleton]);
    const reset = useCallback(() => {
        dispatch(actions.reset());
    }, []);
    return {
        optionsProps: {
            Option: renderOption,
            options: [...options, ...skeletonOptions],
            optionsListProps: {
                ref: listRef,
                inputProps: {
                    onChange: onQueryStringChange,
                    value: queryString,
                },
            },
            onOpen,
        },
        reset,
    };
}

export { useLazyLoading };
