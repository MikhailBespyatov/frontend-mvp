import React, { forwardRef, useState, useRef, useCallback, useEffect } from 'react';
import cn from 'classnames';
import mergeRefs from 'react-merge-refs';
import { CalendarMIcon } from '@alfalab/icons-glyph/CalendarMIcon';
import { Popover } from '../../popover/modern';
import { parseDateString, isCompleteDateInput, formatDate, DateInput, SUPPORTS_INPUT_TYPE_DATE } from '../../date-input/modern';
import { Calendar, dateInLimits } from '../../calendar/modern';

var styles = {"component":"calendar-input__component_qd42g","block":"calendar-input__block_qd42g","calendarContainer":"calendar-input__calendarContainer_qd42g","calendarIcon":"calendar-input__calendarIcon_qd42g","nativeInput":"calendar-input__nativeInput_qd42g"};
require('./index.css');

const CalendarInput = forwardRef(({ block = false, className, inputClassName, popoverClassName, defaultOpen = false, defaultMonth, defaultValue = '', calendarPosition = 'popover', value, dataTestId, calendarProps = {}, minDate = calendarProps.minDate, maxDate = calendarProps.maxDate, offDays = calendarProps.offDays || [], preventFlip, mobileMode = 'popover', wrapperRef = null, disabled, onChange, onInputChange, onCalendarChange, onKeyDown, readOnly, Calendar: Calendar$1 = Calendar, popoverPosition = 'bottom-start', zIndexPopover, useAnchorWidth, rightAddons, ...restProps }, ref) => {
    const uncontrolled = value === undefined;
    const shouldRenderNative = SUPPORTS_INPUT_TYPE_DATE && mobileMode === 'native';
    const shouldRenderOnlyInput = mobileMode === 'input';
    const shouldRenderStatic = calendarPosition === 'static' && !shouldRenderOnlyInput;
    const shouldRenderPopover = calendarPosition === 'popover' && !shouldRenderNative && !shouldRenderOnlyInput;
    const [open, setOpen] = useState(false);
    const [stateValue, setStateValue] = useState(defaultValue);
    const inputValue = uncontrolled ? stateValue : value;
    const calendarValue = inputValue ? parseDateString(inputValue).getTime() : undefined;
    const isCalendarValueValid = calendarValue &&
        dateInLimits(calendarValue, minDate, maxDate) &&
        !offDays.includes(calendarValue);
    const inputDisabled = disabled || readOnly;
    const inputWrapperRef = useRef(null);
    const calendarRef = useRef(null);
    const handleKeyDown = useCallback((event) => {
        if (event.target.tagName === 'INPUT' && event.key === 'Enter') {
            setOpen(!open);
        }
        if (event.key === 'Escape') {
            setOpen(false);
        }
    }, [open]);
    const handleClick = useCallback(() => {
        if (!open)
            setOpen(true);
    }, [open]);
    const handleFocus = useCallback((event) => {
        setOpen(true);
        if (!open && event.target.tagName !== 'INPUT' && calendarRef.current) {
            calendarRef.current.focus();
        }
    }, [open]);
    const handleBlur = useCallback((event) => {
        const target = (event.relatedTarget || document.activeElement);
        if (calendarRef.current && calendarRef.current.contains(target) === false) {
            setOpen(false);
        }
    }, []);
    const handleInputKeyDown = useCallback((event) => {
        if (['ArrowDown', 'ArrowUp'].includes(event.key) && calendarRef.current) {
            event.preventDefault();
            calendarRef.current.focus();
        }
        if (onKeyDown)
            onKeyDown(event);
    }, [onKeyDown]);
    const changeHandler = useCallback((event, newValue, newDate, initiator = 'input', shouldChange = true) => {
        if (initiator === 'input' && event && onInputChange) {
            onInputChange(event, { value: newValue, date: newDate });
        }
        if (initiator === 'calendar' && onCalendarChange) {
            onCalendarChange(newDate.getTime());
        }
        if (shouldChange) {
            if (uncontrolled) {
                setStateValue(newValue);
            }
            if (onChange) {
                onChange(event, { date: newDate, value: newValue });
            }
        }
    }, [onCalendarChange, onChange, onInputChange, uncontrolled]);
    const handleInputChange = useCallback((event, payload) => {
        changeHandler(event, payload.value, payload.date, 'input', !payload.value || isCompleteDateInput(payload.value));
    }, [changeHandler]);
    const handleCalendarChange = useCallback(date => {
        changeHandler(null, formatDate(date), new Date(date), 'calendar');
        setOpen(false);
    }, [changeHandler]);
    const handleCalendarWrapperMouseDown = useCallback((event) => {
        // Не дает инпуту терять фокус при выборе даты
        event.preventDefault();
    }, []);
    useEffect(() => {
        setOpen(defaultOpen);
    }, [defaultOpen]);
    const renderCalendar = useCallback(() => (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    React.createElement("div", { onMouseDown: handleCalendarWrapperMouseDown },
        React.createElement(Calendar$1, Object.assign({}, calendarProps, { ref: calendarRef, defaultMonth: defaultMonth, value: isCalendarValueValid ? calendarValue : undefined, onChange: handleCalendarChange, minDate: minDate, maxDate: maxDate, offDays: offDays })))), [
        calendarProps,
        calendarValue,
        defaultMonth,
        handleCalendarChange,
        handleCalendarWrapperMouseDown,
        isCalendarValueValid,
        maxDate,
        minDate,
        offDays,
    ]);
    return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    React.createElement("div", { className: cn(styles.component, className, {
            [styles.block]: block,
        }), tabIndex: -1, onKeyDown: inputDisabled ? undefined : handleKeyDown, onClick: inputDisabled ? undefined : handleClick, onFocus: inputDisabled ? undefined : handleFocus, onBlur: handleBlur, "data-test-id": dataTestId },
        React.createElement(DateInput, Object.assign({}, restProps, { ref: ref, wrapperRef: mergeRefs([wrapperRef, inputWrapperRef]), value: inputValue, defaultValue: defaultValue, disabled: disabled, readOnly: readOnly, mobileMode: mobileMode === 'native' ? 'native' : 'input', rightAddons: React.createElement(React.Fragment, null,
                rightAddons,
                React.createElement(CalendarMIcon, { className: styles.calendarIcon })), onKeyDown: handleInputKeyDown, onChange: handleInputChange, block: true })),
        shouldRenderStatic && renderCalendar(),
        shouldRenderPopover && (React.createElement(Popover, { open: open, useAnchorWidth: useAnchorWidth, anchorElement: inputWrapperRef.current, popperClassName: styles.calendarContainer, className: popoverClassName, position: popoverPosition, offset: [0, 8], withTransition: false, preventFlip: preventFlip, zIndex: zIndexPopover }, renderCalendar()))));
});

export { CalendarInput };
