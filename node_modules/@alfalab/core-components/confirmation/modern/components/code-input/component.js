import React, { forwardRef, useRef, useImperativeHandle, useCallback, useEffect } from 'react';
import cn from 'classnames';
import { usePrevious } from '@alfalab/hooks';
import { mergeArrays } from './utils.js';

var styles = {"component":"confirmation__component_1s527","input":"confirmation__input_1s527","hasError":"confirmation__hasError_1s527","center":"confirmation__center_1s527","disabled":"confirmation__disabled_1s527","compact":"confirmation__compact_1s527","shake":"confirmation__shake_1s527"};
require('./index.css');

const Input = ({ index, slotsCount, error, processing, value, alignContent, handleChange, handleInputKeyDown, setRef, focus, }) => {
    const splittedValue = value.split('');
    const inputRef = useRef(null);
    const onChange = (event) => {
        const { value: targetValue } = event.target;
        if (/^\d$/.test(targetValue)) {
            const newValues = [...splittedValue];
            newValues[index] = targetValue;
            handleChange(newValues.join(''));
        }
        else if (/^\d{1,}$/.test(targetValue) && index !== slotsCount - 1) {
            /*
             * если пользователь хочет ввести более 1 цифры в инпут,
             * то предполагаем, что это вставка кода (например, из смс)
             */
            const newValues = mergeArrays({
                sourceArray: splittedValue,
                targetArray: targetValue.split(''),
                startIndex: index,
                resultArrayLength: slotsCount,
            });
            handleChange(newValues.join(''));
        }
    };
    const onInputKeyDown = (event) => {
        const { key } = event;
        const newValues = [...splittedValue];
        switch (key) {
            case 'Backspace':
            case 'Delete':
                newValues[index] = '';
                handleChange(newValues.join('').trim());
                if (index !== 0) {
                    focus(index - 1);
                }
                break;
            case 'ArrowRight':
                if (index !== slotsCount - 1) {
                    focus(index + 1);
                }
                break;
            case 'ArrowLeft':
                if (index !== 0) {
                    focus(index - 1);
                }
                break;
            case 'Home':
                focus(0);
                break;
            case 'End':
                focus(slotsCount - 1);
                break;
        }
        handleInputKeyDown(event);
    };
    const handleRef = (node) => {
        inputRef.current = node;
        setRef({ node, index });
    };
    return (React.createElement("input", { className: cn(styles.input, styles[alignContent], {
            [styles.hasError]: error,
            [styles.disabled]: processing,
        }), disabled: processing, value: splittedValue[index] || '', autoComplete: index === 0 ? 'one-time-code' : '', inputMode: 'numeric', pattern: '[0-9]*', onChange: onChange, onKeyDown: onInputKeyDown, ref: handleRef }));
};
const CodeInput = forwardRef(({ processing, value = '', slotsCount, error, handleInputKeyDown, handleChange, className, alignContent, }, ref) => {
    const inputs = useRef([]);
    useImperativeHandle(ref, () => inputs.current[0]);
    const prevValue = usePrevious(value) || '';
    const focus = useCallback((index) => {
        const input = inputs.current[index];
        if (input) {
            input.focus();
            input.setSelectionRange(1, 1);
        }
    }, []);
    const setRef = useCallback(({ node, index }) => {
        inputs.current[index] = node;
    }, []);
    /**
     * Устанавливаем фокус на инпуте:
     * 1) если код введен неверно
     * 2) по нажатию кнопки 'Запросить код'
     */
    useEffect(() => {
        const inputIndex = value.length === slotsCount ? value.length - 1 : value.length;
        const needFocus = !processing || error;
        if (needFocus && value.length === prevValue.length) {
            focus(inputIndex);
        }
    }, [focus, error, slotsCount, value.length, prevValue.length, processing]);
    useEffect(() => {
        if (value.length > prevValue.length && value.length < slotsCount) {
            /**
             * Если value.length увеличился - ставим фокус на следующем инпуте
             */
            const nextInputIndex = value.length;
            focus(nextInputIndex);
        }
        else if (value.length <= prevValue.length && value.length > 0) {
            /**
             * Если value.length уменьшился - ставим фокус на предыдущем инпуте
             */
            const nextInputIndex = value.length - 1;
            focus(nextInputIndex);
        }
    }, [value.length, prevValue.length, slotsCount, focus]);
    return (React.createElement("div", { className: cn(styles.component, className, {
            [styles.shake]: Boolean(error),
            [styles.compact]: slotsCount > 6,
        }) }, new Array(slotsCount).fill('').map((_, index) => (React.createElement(Input, { value: value, index: index, error: error, processing: processing, slotsCount: slotsCount, alignContent: alignContent, handleChange: handleChange, handleInputKeyDown: handleInputKeyDown, setRef: setRef, focus: focus, 
        // eslint-disable-next-line react/no-array-index-key
        key: index })))));
});

export { CodeInput };
