import React, { forwardRef, useRef, useState, useCallback } from 'react';
import cn from 'classnames';
import mergeRefs from 'react-merge-refs';
import { useFocus } from '@alfalab/hooks';
import { Button } from '../../button/modern';

var styles = {"component":"plate__component_1mnzm","foldable":"plate__foldable_1mnzm","focused":"plate__focused_1mnzm","inner":"plate__inner_1mnzm","common":"plate__common_1mnzm","negative":"plate__negative_1mnzm","positive":"plate__positive_1mnzm","attention":"plate__attention_1mnzm","isHidden":"plate__isHidden_1mnzm","leftAddons":"plate__leftAddons_1mnzm","title":"plate__title_1mnzm","content":"plate__content_1mnzm","isFolded":"plate__isFolded_1mnzm","contentContainer":"plate__contentContainer_1mnzm","withoutTitle":"plate__withoutTitle_1mnzm","contentInner":"plate__contentInner_1mnzm","closer":"plate__closer_1mnzm","folder":"plate__folder_1mnzm","buttons":"plate__buttons_1mnzm","button":"plate__button_1mnzm"};
require('./index.css');

const Plate = forwardRef(({ hasCloser, foldable: foldableProp = false, folded: foldedProp, defaultFolded = true, leftAddons, children, buttons = [], title, view = 'common', className, buttonsClassName, contentClassName, dataTestId, onClick, onClose, onToggle, }, ref) => {
    const plateRef = useRef(null);
    const contentRef = useRef(null);
    const [focused] = useFocus(plateRef, 'keyboard');
    const [isHidden, setIsHidden] = useState(false);
    const [foldedState, setFoldedState] = useState(defaultFolded);
    const uncontrolled = foldedProp === undefined;
    const foldable = !!title && !!children && foldableProp;
    const folded = uncontrolled ? foldedState : foldedProp;
    const hasButtons = Array.isArray(buttons) && buttons.length > 0;
    const hasContent = children || hasButtons;
    const handleClick = useCallback(event => {
        const eventInsideComponent = plateRef.current && plateRef.current.contains(event.target);
        const eventInsideContent = contentRef.current && contentRef.current.contains(event.target);
        const clickSimilarKeys = ['Enter', ' '].includes(event.key);
        const shouldChangeIsFolded = eventInsideComponent &&
            !eventInsideContent &&
            (event.type === 'click' || clickSimilarKeys);
        if (foldable && shouldChangeIsFolded) {
            if (uncontrolled) {
                setFoldedState(!foldedState);
            }
            if (onToggle) {
                onToggle(event, { folded: !(uncontrolled ? foldedState : foldedProp) });
            }
        }
        if (onClick) {
            onClick(event);
        }
    }, [foldable, onClick, uncontrolled, onToggle, foldedState, foldedProp]);
    const handleClose = useCallback(event => {
        setIsHidden(true);
        if (onClose) {
            onClose(event);
        }
    }, [onClose]);
    const renderButtons = useCallback(() => (React.createElement("div", { className: cn(styles.buttons, buttonsClassName) }, buttons.map((button, index) => button
        ? React.cloneElement(button, {
            // eslint-disable-next-line react/no-array-index-key
            key: index,
            size: 'xs',
            view: index === 0 ? 'outlined' : 'link',
            className: cn(button.props.className, styles.button),
        })
        : null))), [buttons, buttonsClassName]);
    return (
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    React.createElement("div", { className: cn(styles.component, styles[view], {
            [styles.foldable]: foldable,
            [styles.focused]: focused,
            [styles.isHidden]: hasCloser && isHidden,
            [styles.isFolded]: foldable && folded,
        }, className), onClick: handleClick, onKeyDown: handleClick, role: 'alert', ref: mergeRefs([plateRef, ref]), 
        /* eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex */
        tabIndex: foldable ? 0 : -1, "data-test-id": dataTestId },
        React.createElement("div", { className: styles.inner },
            leftAddons && React.createElement("div", { className: styles.leftAddons }, leftAddons),
            React.createElement("div", { className: cn(styles.contentContainer, contentClassName, {
                    [styles.withoutTitle]: !title,
                }) },
                title && React.createElement("div", { className: styles.title }, title),
                hasContent && (React.createElement("div", { ref: contentRef, className: cn(styles.content, {
                        [styles.isFolded]: foldable && folded,
                    }) },
                    React.createElement("div", { className: styles.contentInner },
                        children,
                        hasButtons ? renderButtons() : null)))),
            foldable && (React.createElement("div", { className: cn(styles.folder, {
                    [styles.isFolded]: folded,
                }) })),
            hasCloser && !foldable && (React.createElement(Button, { className: styles.closer, "aria-label": '\u0437\u0430\u043A\u0440\u044B\u0442\u044C', view: 'ghost', onClick: handleClose })))));
});
/**
 * Для отображения в сторибуке
 */
Plate.defaultProps = {
    foldable: false,
    defaultFolded: true,
    view: 'common',
};

export { Plate };
