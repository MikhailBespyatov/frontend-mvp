import React, { useState, useRef, useCallback, useEffect, Fragment } from 'react';
import cn from 'classnames';
import mergeRefs from 'react-merge-refs';
import { Popover } from '../../popover/modern';

var styles = {"component":"tooltip__component_19vu5","popper":"tooltip__popper_19vu5","hint":"tooltip__hint_19vu5","arrow":"tooltip__arrow_19vu5","target":"tooltip__target_19vu5","overlap":"tooltip__overlap_19vu5"};
require('./index.css');

const Tooltip = ({ children, content, trigger = 'hover', onCloseDelay = 300, onOpenDelay = 300, dataTestId, open: forcedOpen, offset = [0, 16], position, contentClassName, arrowClassName, popoverClassName, updatePopover, targetClassName, zIndex, onClose, onOpen, getPortalContainer, view = 'tooltip', targetRef = null, fallbackPlacements, preventOverflow = true, availableHeight = false, }) => {
    const [visible, setVisible] = useState(!!forcedOpen);
    const [target, setTarget] = useState(null);
    const contentRef = useRef(null);
    const timer = useRef(0);
    const show = forcedOpen === undefined ? visible : forcedOpen;
    const open = () => {
        if (!show) {
            setVisible(true);
            if (onOpen) {
                onOpen();
            }
        }
    };
    const close = useCallback(() => {
        if (show) {
            setVisible(false);
            if (onClose) {
                onClose();
            }
        }
    }, [onClose, show]);
    const toggle = () => {
        if (show) {
            close();
        }
        else {
            open();
        }
    };
    const clickedOutside = useCallback((node) => {
        if (target && target.contains(node)) {
            return false;
        }
        if (contentRef.current && contentRef.current.contains(node)) {
            return false;
        }
        return true;
    }, [target]);
    useEffect(() => {
        const handleBodyClick = (event) => {
            const eventTarget = event.target;
            if (clickedOutside(eventTarget)) {
                close();
            }
        };
        document.body.addEventListener('click', handleBodyClick);
        return () => {
            document.body.removeEventListener('click', handleBodyClick);
            clearTimeout(timer.current);
        };
    }, [clickedOutside, close]);
    const handleTargetClick = () => {
        toggle();
    };
    const handleMouseOver = () => {
        clearTimeout(timer.current);
        timer.current = window.setTimeout(() => {
            open();
        }, onOpenDelay);
    };
    const handleMouseOut = () => {
        clearTimeout(timer.current);
        timer.current = window.setTimeout(() => {
            close();
        }, onCloseDelay);
    };
    const handleTouchStart = (event) => {
        const eventTarget = event.target;
        clearTimeout(timer.current);
        if (clickedOutside(eventTarget)) {
            timer.current = window.setTimeout(() => {
                close();
            }, onCloseDelay);
        }
        else {
            open();
        }
    };
    const onClickProps = { onClick: handleTargetClick };
    const onHoverProps = {
        onMouseOver: handleMouseOver,
        onMouseOut: handleMouseOut,
        onTouchStart: handleTouchStart,
    };
    const getTargetProps = () => {
        const props = {
            className: cn(styles.target, targetClassName),
        };
        switch (trigger) {
            case 'click':
                return {
                    ...props,
                    ...onClickProps,
                };
            case 'hover':
                return {
                    ...props,
                    ...onHoverProps,
                };
            default:
                return {};
        }
    };
    const getContentProps = () => {
        const props = {
            ref: contentRef,
            'data-test-id': dataTestId,
            className: cn(styles.component, contentClassName),
        };
        switch (trigger) {
            case 'hover':
                return {
                    ...props,
                    ...onHoverProps,
                };
            default:
                return props;
        }
    };
    return (React.createElement(Fragment, null,
        React.createElement("div", Object.assign({ ref: mergeRefs([targetRef, setTarget]) }, getTargetProps()),
            children.props.disabled && React.createElement("div", { className: styles.overlap }),
            children),
        React.createElement(Popover, { anchorElement: target, open: show, getPortalContainer: getPortalContainer, arrowClassName: cn(arrowClassName, styles.arrow), popperClassName: cn(styles.popper, styles[view]), className: popoverClassName, offset: offset, withArrow: true, position: position, update: updatePopover, zIndex: zIndex, fallbackPlacements: fallbackPlacements, preventOverflow: preventOverflow, availableHeight: availableHeight },
            React.createElement("div", Object.assign({}, getContentProps()), content))));
};

export { Tooltip };
