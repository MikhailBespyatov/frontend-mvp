Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./tslib.es6-2be2aee7.js');
var React = require('react');
var cn = require('classnames');
var recharts = require('recharts');
var components_LinearGradient = require('./components/LinearGradient.js');
require('../../typography/cssm');
require('./icons/Circle.js');
require('./icons/CircleLine.js');
require('./icons/FilledCircle.js');
require('./icons/StrokeCircle.js');
require('./components/Legends/index.module.css');
var components_Legends_index = require('./components/Legends/index.js');
require('./icons/Point.js');
require('./components/Dot/index.module.css');
var components_Dot_index = require('./components/Dot/index.js');
require('./hooks/useSettings/utils/setComposedChartsMargin.js');
require('./hooks/useSettings/utils/setDatas.js');
require('./hooks/useSettings/utils/setGradientCharts.js');
require('./hooks/useSettings/utils/setLegendMargin.js');
require('./hooks/useSettings/utils/sortByIndex.js');
var hooks_useSettings_index = require('./hooks/useSettings/index.js');
require('./hooks/usePathBar/utils/getRadius.js');
require('./hooks/usePathBar/index.js');
var components_CustomizedLabel = require('./components/CustomizedLabel.js');
var components_RectBar = require('./components/RectBar.js');
require('./components/Tick/index.module.css');
var components_Tick_index = require('./components/Tick/index.js');
require('./components/TooltipContent/index.module.css');
var components_TooltipContent_index = require('./components/TooltipContent/index.js');
var styles = require('./index.module.css');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var cn__default = /*#__PURE__*/_interopDefaultLegacy(cn);
var styles__default = /*#__PURE__*/_interopDefaultLegacy(styles);

var CustomizedHOC = function (Component, options) {
    var NewComponent = function (props) {
        return React__default['default'].createElement(Component, tslib_es6.__assign({}, props, options));
    };
    return NewComponent;
};

var Chart = function (props) {
    var _a;
    var _b = hooks_useSettings_index.useSettings(props), _c = _b[0], state = _c.state, data = _c.data, charts = _c.charts, filterCount = _c.filterCount, _d = _b[1], setCharts = _d.setCharts, setFilterCount = _d.setFilterCount;
    var _e = React.useState({
        prev: null,
        active: null,
    }), activeDotsState = _e[0], setActiveDotsState = _e[1];
    var _f = React.useState(null), yBrush = _f[0], setYBrush = _f[1];
    var _g = React.useState(null), tooltipArrowSide = _g[0], setTooltipArrowSide = _g[1];
    var _h = React.useState(0), heightLegend = _h[0], setHeightLegend = _h[1];
    var svgRef = React.useRef(null);
    var tooltipRef = React.useRef(null);
    var renderGradient = React.useMemo(function () {
        if (!state)
            return null;
        return state.series.map(function (item) {
            var chart = item.chart, gradient = item.gradient;
            if (chart !== 'gradient' || !gradient)
                return null;
            var gid = gradient.gid, points = gradient.points;
            return (React__default['default'].createElement(components_LinearGradient.LinearGradient, { key: state.id + "-" + gid, id: state.id, gid: gid, points: points }));
        });
    }, [state]);
    var toggleChart = React.useCallback(function (item) {
        var chart = item.chart, dataKey = item.properties.dataKey;
        var withGrad = chart === 'area';
        var changed = false;
        if (charts["" + dataKey] && filterCount > 1) {
            changed = true;
            setFilterCount(function (prev) { return prev - 1; });
        }
        if (!charts["" + dataKey]) {
            changed = true;
            setFilterCount(function (prev) { return prev + 1; });
        }
        if (!changed)
            return;
        setCharts(function (prev) {
            var newState = tslib_es6.__assign({}, prev);
            newState["" + dataKey] = !newState["" + dataKey];
            if (withGrad)
                newState[dataKey + "-gradient"] = !newState[dataKey + "-gradient"];
            return newState;
        });
    }, [charts, filterCount, setCharts, setFilterCount]);
    var legendRef = React.useCallback(function (node) {
        if (node !== null) {
            setTimeout(function () {
                var height = node.getBoundingClientRect().height;
                setHeightLegend(height);
            }, 0);
        }
    }, []);
    var renderLegend = React.useMemo(function () {
        var _a, _b, _c;
        if (!(state === null || state === void 0 ? void 0 : state.legend))
            return null;
        var translate = ((_a = state === null || state === void 0 ? void 0 : state.xAxis) === null || _a === void 0 ? void 0 : _a.tickMargin) && ((_b = state === null || state === void 0 ? void 0 : state.legend) === null || _b === void 0 ? void 0 : _b.verticalAlign) !== 'top'
            ? state.xAxis.tickMargin + (((_c = state === null || state === void 0 ? void 0 : state.brush) === null || _c === void 0 ? void 0 : _c.brushMargin) || 0)
            : 0;
        return (React__default['default'].createElement(recharts.Legend, tslib_es6.__assign({}, (state.legend || null), { content: React__default['default'].createElement(components_Legends_index.Legends, { legend: state.legend, series: state.series, id: state.id, toggleChart: toggleChart, ref: legendRef, charts: charts }), wrapperStyle: {
                transform: "translateY(" + translate + "px)",
            } })));
    }, [state, charts, toggleChart, legendRef]);
    var renderCartesianGrid = React.useMemo(function () {
        if (!(state === null || state === void 0 ? void 0 : state.cartesianGrid))
            return null;
        return React__default['default'].createElement(recharts.CartesianGrid, tslib_es6.__assign({}, state.cartesianGrid));
    }, [state]);
    var renderXAxis = React.useMemo(function () {
        var _a;
        if (!(state === null || state === void 0 ? void 0 : state.xAxis))
            return null;
        var tick;
        if (((_a = state === null || state === void 0 ? void 0 : state.xAxis) === null || _a === void 0 ? void 0 : _a.tickType) === 'point') {
            tick = CustomizedHOC(components_Tick_index.Tick, { xAxis: state.xAxis });
        }
        else if (typeof state.xAxis.tick === 'boolean') {
            tick = state.xAxis.tick;
        }
        else {
            tick = true;
        }
        return React__default['default'].createElement(recharts.XAxis, tslib_es6.__assign({}, state.xAxis, { tick: tick }));
    }, [state]);
    var renderYAxis = React.useMemo(function () {
        var _a;
        if (!(state === null || state === void 0 ? void 0 : state.yAxis))
            return null;
        var tick;
        if ((_a = state === null || state === void 0 ? void 0 : state.yAxis) === null || _a === void 0 ? void 0 : _a.tick) {
            tick = CustomizedHOC(state.yAxis.tick, { state: state });
        }
        else if (typeof state.yAxis.tick === 'boolean') {
            tick = state.yAxis.tick;
        }
        else {
            tick = true;
        }
        return React__default['default'].createElement(recharts.YAxis, tslib_es6.__assign({}, state.yAxis, { tick: tick }));
    }, [state]);
    var renderBrush = React.useMemo(function () {
        if (!(state === null || state === void 0 ? void 0 : state.brush))
            return null;
        return React__default['default'].createElement(recharts.Brush, tslib_es6.__assign({ y: typeof yBrush === 'number' ? yBrush : 0 }, state.brush));
    }, [state, yBrush]);
    var renderTooltip = React.useMemo(function () {
        if (!(state === null || state === void 0 ? void 0 : state.tooltip))
            return null;
        return (React__default['default'].createElement(recharts.Tooltip, tslib_es6.__assign({ ref: tooltipRef }, state.tooltip, { content: CustomizedHOC(components_TooltipContent_index.TooltipContent, { series: state.series, tooltipArrowSide: tooltipArrowSide }) })));
    }, [state, tooltipArrowSide]);
    var renderChartsItems = React.useMemo(function () {
        if (!state || !charts)
            return null;
        return state.series.map(function (item) {
            var chart = item.chart, properties = item.properties, radius = item.radius, labelList = item.labelList;
            var show = charts["" + properties.dataKey];
            switch (chart) {
                case 'bar':
                    return show && !(item === null || item === void 0 ? void 0 : item.hide) ? (React__default['default'].createElement(recharts.Bar, tslib_es6.__assign({ key: state.id + "-" + properties.dataKey }, properties, { shape: React__default['default'].createElement(components_RectBar.RectBar, { radius: radius }) }),
                        labelList && (React__default['default'].createElement(recharts.LabelList, tslib_es6.__assign({ dataKey: properties.dataKey.toString() }, labelList, { content: React__default['default'].createElement(components_CustomizedLabel.CustomizedLabel, { radius: radius }) }))),
                        data.map(function (_, index) {
                            var key = state.id + "-" + properties.dataKey + "-" + index;
                            return (React__default['default'].createElement(recharts.Cell, { key: key, className: cn__default['default'](styles__default['default'].bar, typeof activeDotsState.active === 'number' &&
                                    activeDotsState.active !== index
                                    ? styles__default['default'].unfocused
                                    : '') }));
                        }))) : null;
                case 'area':
                case 'line':
                    return show && !(item === null || item === void 0 ? void 0 : item.hide) ? (React__default['default'].createElement(recharts.Line, tslib_es6.__assign({ key: state.id + "-" + properties.dataKey }, properties, { dot: properties.dot && properties.dotSettings
                            ? CustomizedHOC(components_Dot_index.Dot, {
                                activeDot: activeDotsState.active,
                                dotSettings: properties.dotSettings,
                                inherit: (properties === null || properties === void 0 ? void 0 : properties.inheritStroke) ? properties.inheritStroke
                                    : false,
                            })
                            : false, activeDot: false }))) : null;
                case 'gradient':
                    return show && !(item === null || item === void 0 ? void 0 : item.hide) ? (React__default['default'].createElement(recharts.Area, tslib_es6.__assign({}, item.properties, { key: state.id + "-" + item.properties.dataKey, dataKey: "" + item.properties.dataKey, stroke: 'transparent', fill: item.gradient.gid
                            ? "url(#" + state.id + "-" + item.gradient.gid + ")"
                            : item.properties.fill, dot: false, activeDot: false }))) : null;
                default:
                    return null;
            }
        });
    }, [charts, state, activeDotsState, data]);
    // Позиционирование brush
    React.useEffect(function () {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!state || !state.brush)
            return;
        if (!heightLegend || heightLegend === 0)
            return;
        var align = (_a = state === null || state === void 0 ? void 0 : state.legend) === null || _a === void 0 ? void 0 : _a.verticalAlign;
        var legendHeight = align === 'top' ? 0 : heightLegend;
        var marginTick = ((_b = state === null || state === void 0 ? void 0 : state.xAxis) === null || _b === void 0 ? void 0 : _b.tickMargin) ? (_c = state === null || state === void 0 ? void 0 : state.xAxis) === null || _c === void 0 ? void 0 : _c.tickMargin : 0;
        var brushY = (((_d = svgRef.current) === null || _d === void 0 ? void 0 : _d.clientHeight) ? svgRef.current.clientHeight : 0) -
            legendHeight -
            state.brush.height -
            (((_f = (_e = state === null || state === void 0 ? void 0 : state.composeChart) === null || _e === void 0 ? void 0 : _e.margin) === null || _f === void 0 ? void 0 : _f.bottom) ? state.composeChart.margin.bottom : 0) +
            marginTick +
            (((_g = state.brush) === null || _g === void 0 ? void 0 : _g.brushMargin) ? state.brush.brushMargin : 0);
        setYBrush(brushY);
    }, [heightLegend, state]);
    var leaveEvent = function (isTooltipActive) {
        if (isTooltipActive)
            return;
        if (typeof activeDotsState.prev !== 'number' || typeof activeDotsState.active !== 'number')
            return;
        setActiveDotsState({
            prev: null,
            active: null,
        });
    };
    var arrowTooltipEvent = function (activeCoordinate) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!((_a = state === null || state === void 0 ? void 0 : state.tooltip) === null || _a === void 0 ? void 0 : _a.arrow))
            return;
        if (((_b = state === null || state === void 0 ? void 0 : state.tooltip) === null || _b === void 0 ? void 0 : _b.arrow) && (activeCoordinate === null || activeCoordinate === void 0 ? void 0 : activeCoordinate.x)) {
            var side = (((_c = svgRef === null || svgRef === void 0 ? void 0 : svgRef.current) === null || _c === void 0 ? void 0 : _c.clientWidth) || 0) -
                (((_e = (_d = state === null || state === void 0 ? void 0 : state.composeChart) === null || _d === void 0 ? void 0 : _d.margin) === null || _e === void 0 ? void 0 : _e.right) || 0) -
                activeCoordinate.x -
                (((_g = (_f = tooltipRef.current) === null || _f === void 0 ? void 0 : _f.state) === null || _g === void 0 ? void 0 : _g.boxWidth) || 0) >
                20;
            setTooltipArrowSide(side);
        }
    };
    var hoverEvent = function (isTooltipActive, activeTooltipIndex) {
        if (!isTooltipActive)
            return;
        if (typeof activeDotsState.active === 'number' &&
            activeTooltipIndex === activeDotsState.active)
            return;
        if (typeof activeTooltipIndex === 'number' && typeof activeDotsState.active !== 'number') {
            setActiveDotsState({
                prev: activeTooltipIndex,
                active: activeTooltipIndex,
            });
        }
        if (typeof activeTooltipIndex === 'number' && typeof activeDotsState.prev === 'number') {
            setActiveDotsState(function (prev) {
                return {
                    prev: prev.active,
                    active: activeTooltipIndex,
                };
            });
        }
    };
    var mouseMove = function (e) {
        if (!(state === null || state === void 0 ? void 0 : state.tooltip))
            return;
        arrowTooltipEvent(e.activeCoordinate);
        hoverEvent(e.isTooltipActive, e.activeTooltipIndex);
        leaveEvent(e.isTooltipActive);
    };
    var mouseLeave = function (e) {
        if (!(state === null || state === void 0 ? void 0 : state.tooltip))
            return;
        leaveEvent(e.isTooltipActive);
    };
    if (!data || !charts || !state)
        return null;
    return (React__default['default'].createElement("div", { className: styles__default['default'].coreChart, ref: svgRef, id: (state === null || state === void 0 ? void 0 : state.id) || '', style: { width: '100%', height: '100%' } },
        React__default['default'].createElement(recharts.ResponsiveContainer, { debounce: ((_a = state === null || state === void 0 ? void 0 : state.responsiveContainer) === null || _a === void 0 ? void 0 : _a.debounce) ? state.responsiveContainer.debounce : 0, width: '100%' },
            React__default['default'].createElement(recharts.ComposedChart, tslib_es6.__assign({}, state === null || state === void 0 ? void 0 : state.composeChart, { onMouseMove: mouseMove, onMouseLeave: mouseLeave, data: data }),
                React__default['default'].createElement("defs", null, renderGradient),
                state.cartesianGrid && renderCartesianGrid,
                state.xAxis && renderXAxis,
                state.yAxis && renderYAxis,
                renderChartsItems,
                state.tooltip && renderTooltip,
                state.brush && renderBrush,
                state.legend && renderLegend))));
};

exports.Chart = Chart;
