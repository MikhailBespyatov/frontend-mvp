import React, { useState, useRef, useMemo, useCallback, useEffect } from 'react';
import cn from 'classnames';
import { Legend, CartesianGrid, XAxis, YAxis, Brush, Tooltip, Area, Line, Bar, LabelList, Cell, ResponsiveContainer, ComposedChart } from 'recharts';
import { LinearGradient } from './components/LinearGradient.js';
import '../../typography/modern';
import './icons/Circle.js';
import './icons/CircleLine.js';
import './icons/FilledCircle.js';
import './icons/StrokeCircle.js';
import { Legends } from './components/Legends/index.js';
import './icons/Point.js';
import { Dot } from './components/Dot/index.js';
import './hooks/useSettings/utils/setComposedChartsMargin.js';
import './hooks/useSettings/utils/setDatas.js';
import './hooks/useSettings/utils/setGradientCharts.js';
import './hooks/useSettings/utils/setLegendMargin.js';
import './hooks/useSettings/utils/sortByIndex.js';
import { useSettings } from './hooks/useSettings/index.js';
import './hooks/usePathBar/utils/getRadius.js';
import './hooks/usePathBar/index.js';
import { CustomizedLabel } from './components/CustomizedLabel.js';
import { RectBar } from './components/RectBar.js';
import { Tick } from './components/Tick/index.js';
import { TooltipContent } from './components/TooltipContent/index.js';

const CustomizedHOC = (Component, options) => {
    const NewComponent = props => {
        return React.createElement(Component, Object.assign({}, props, options));
    };
    return NewComponent;
};

var styles = {"coreChart":"chart__coreChart_1wngk","bar":"chart__bar_1wngk","unfocused":"chart__unfocused_1wngk"};
require('./index.css');

const Chart = (props) => {
    const [{ state, data, charts, filterCount }, { setCharts, setFilterCount }] = useSettings(props);
    const [activeDotsState, setActiveDotsState] = useState({
        prev: null,
        active: null,
    });
    const [yBrush, setYBrush] = useState(null);
    const [tooltipArrowSide, setTooltipArrowSide] = useState(null);
    const [heightLegend, setHeightLegend] = useState(0);
    const svgRef = useRef(null);
    const tooltipRef = useRef(null);
    const renderGradient = useMemo(() => {
        if (!state)
            return null;
        return state.series.map((item) => {
            const { chart, gradient } = item;
            if (chart !== 'gradient' || !gradient)
                return null;
            const { gid, points } = gradient;
            return (React.createElement(LinearGradient, { key: `${state.id}-${gid}`, id: state.id, gid: gid, points: points }));
        });
    }, [state]);
    const toggleChart = useCallback((item) => {
        const { chart, properties: { dataKey }, } = item;
        const withGrad = chart === 'area';
        let changed = false;
        if (charts[`${dataKey}`] && filterCount > 1) {
            changed = true;
            setFilterCount(prev => prev - 1);
        }
        if (!charts[`${dataKey}`]) {
            changed = true;
            setFilterCount(prev => prev + 1);
        }
        if (!changed)
            return;
        setCharts((prev) => {
            const newState = { ...prev };
            newState[`${dataKey}`] = !newState[`${dataKey}`];
            if (withGrad)
                newState[`${dataKey}-gradient`] = !newState[`${dataKey}-gradient`];
            return newState;
        });
    }, [charts, filterCount, setCharts, setFilterCount]);
    const legendRef = useCallback((node) => {
        if (node !== null) {
            setTimeout(() => {
                const { height } = node.getBoundingClientRect();
                setHeightLegend(height);
            }, 0);
        }
    }, []);
    const renderLegend = useMemo(() => {
        if (!state?.legend)
            return null;
        const translate = state?.xAxis?.tickMargin && state?.legend?.verticalAlign !== 'top'
            ? state.xAxis.tickMargin + (state?.brush?.brushMargin || 0)
            : 0;
        return (React.createElement(Legend, Object.assign({}, (state.legend || null), { content: React.createElement(Legends, { legend: state.legend, series: state.series, id: state.id, toggleChart: toggleChart, ref: legendRef, charts: charts }), wrapperStyle: {
                transform: `translateY(${translate}px)`,
            } })));
    }, [state, charts, toggleChart, legendRef]);
    const renderCartesianGrid = useMemo(() => {
        if (!state?.cartesianGrid)
            return null;
        return React.createElement(CartesianGrid, Object.assign({}, state.cartesianGrid));
    }, [state]);
    const renderXAxis = useMemo(() => {
        if (!state?.xAxis)
            return null;
        let tick;
        if (state?.xAxis?.tickType === 'point') {
            tick = CustomizedHOC(Tick, { xAxis: state.xAxis });
        }
        else if (typeof state.xAxis.tick === 'boolean') {
            tick = state.xAxis.tick;
        }
        else {
            tick = true;
        }
        return React.createElement(XAxis, Object.assign({}, state.xAxis, { tick: tick }));
    }, [state]);
    const renderYAxis = useMemo(() => {
        if (!state?.yAxis)
            return null;
        let tick;
        if (state?.yAxis?.tick) {
            tick = CustomizedHOC(state.yAxis.tick, { state });
        }
        else if (typeof state.yAxis.tick === 'boolean') {
            tick = state.yAxis.tick;
        }
        else {
            tick = true;
        }
        return React.createElement(YAxis, Object.assign({}, state.yAxis, { tick: tick }));
    }, [state]);
    const renderBrush = useMemo(() => {
        if (!state?.brush)
            return null;
        return React.createElement(Brush, Object.assign({ y: typeof yBrush === 'number' ? yBrush : 0 }, state.brush));
    }, [state, yBrush]);
    const renderTooltip = useMemo(() => {
        if (!state?.tooltip)
            return null;
        return (React.createElement(Tooltip, Object.assign({ ref: tooltipRef }, state.tooltip, { content: CustomizedHOC(TooltipContent, { series: state.series, tooltipArrowSide }) })));
    }, [state, tooltipArrowSide]);
    const renderChartsItems = useMemo(() => {
        if (!state || !charts)
            return null;
        return state.series.map((item) => {
            const { chart, properties, radius, labelList } = item;
            const show = charts[`${properties.dataKey}`];
            switch (chart) {
                case 'bar':
                    return show && !item?.hide ? (React.createElement(Bar, Object.assign({ key: `${state.id}-${properties.dataKey}` }, properties, { shape: React.createElement(RectBar, { radius: radius }) }),
                        labelList && (React.createElement(LabelList, Object.assign({ dataKey: properties.dataKey.toString() }, labelList, { content: React.createElement(CustomizedLabel, { radius: radius }) }))),
                        data.map((_, index) => {
                            const key = `${state.id}-${properties.dataKey}-${index}`;
                            return (React.createElement(Cell, { key: key, className: cn(styles.bar, typeof activeDotsState.active === 'number' &&
                                    activeDotsState.active !== index
                                    ? styles.unfocused
                                    : '') }));
                        }))) : null;
                case 'area':
                case 'line':
                    return show && !item?.hide ? (React.createElement(Line, Object.assign({ key: `${state.id}-${properties.dataKey}` }, properties, { dot: properties.dot && properties.dotSettings
                            ? CustomizedHOC(Dot, {
                                activeDot: activeDotsState.active,
                                dotSettings: properties.dotSettings,
                                inherit: properties?.inheritStroke
                                    ? properties.inheritStroke
                                    : false,
                            })
                            : false, activeDot: false }))) : null;
                case 'gradient':
                    return show && !item?.hide ? (React.createElement(Area, Object.assign({}, item.properties, { key: `${state.id}-${item.properties.dataKey}`, dataKey: `${item.properties.dataKey}`, stroke: 'transparent', fill: item.gradient.gid
                            ? `url(#${state.id}-${item.gradient.gid})`
                            : item.properties.fill, dot: false, activeDot: false }))) : null;
                default:
                    return null;
            }
        });
    }, [charts, state, activeDotsState, data]);
    // Позиционирование brush
    useEffect(() => {
        if (!state || !state.brush)
            return;
        if (!heightLegend || heightLegend === 0)
            return;
        const align = state?.legend?.verticalAlign;
        const legendHeight = align === 'top' ? 0 : heightLegend;
        const marginTick = state?.xAxis?.tickMargin ? state?.xAxis?.tickMargin : 0;
        const brushY = (svgRef.current?.clientHeight ? svgRef.current.clientHeight : 0) -
            legendHeight -
            state.brush.height -
            (state?.composeChart?.margin?.bottom ? state.composeChart.margin.bottom : 0) +
            marginTick +
            (state.brush?.brushMargin ? state.brush.brushMargin : 0);
        setYBrush(brushY);
    }, [heightLegend, state]);
    const leaveEvent = (isTooltipActive) => {
        if (isTooltipActive)
            return;
        if (typeof activeDotsState.prev !== 'number' || typeof activeDotsState.active !== 'number')
            return;
        setActiveDotsState({
            prev: null,
            active: null,
        });
    };
    const arrowTooltipEvent = (activeCoordinate) => {
        if (!state?.tooltip?.arrow)
            return;
        if (state?.tooltip?.arrow && activeCoordinate?.x) {
            const side = (svgRef?.current?.clientWidth || 0) -
                (state?.composeChart?.margin?.right || 0) -
                activeCoordinate.x -
                (tooltipRef.current?.state?.boxWidth || 0) >
                20;
            setTooltipArrowSide(side);
        }
    };
    const hoverEvent = (isTooltipActive, activeTooltipIndex) => {
        if (!isTooltipActive)
            return;
        if (typeof activeDotsState.active === 'number' &&
            activeTooltipIndex === activeDotsState.active)
            return;
        if (typeof activeTooltipIndex === 'number' && typeof activeDotsState.active !== 'number') {
            setActiveDotsState({
                prev: activeTooltipIndex,
                active: activeTooltipIndex,
            });
        }
        if (typeof activeTooltipIndex === 'number' && typeof activeDotsState.prev === 'number') {
            setActiveDotsState((prev) => {
                return {
                    prev: prev.active,
                    active: activeTooltipIndex,
                };
            });
        }
    };
    const mouseMove = (e) => {
        if (!state?.tooltip)
            return;
        arrowTooltipEvent(e.activeCoordinate);
        hoverEvent(e.isTooltipActive, e.activeTooltipIndex);
        leaveEvent(e.isTooltipActive);
    };
    const mouseLeave = (e) => {
        if (!state?.tooltip)
            return;
        leaveEvent(e.isTooltipActive);
    };
    if (!data || !charts || !state)
        return null;
    return (React.createElement("div", { className: styles.coreChart, ref: svgRef, id: state?.id || '', style: { width: '100%', height: '100%' } },
        React.createElement(ResponsiveContainer, { debounce: state?.responsiveContainer?.debounce ? state.responsiveContainer.debounce : 0, width: '100%' },
            React.createElement(ComposedChart, Object.assign({}, state?.composeChart, { onMouseMove: mouseMove, onMouseLeave: mouseLeave, data: data }),
                React.createElement("defs", null, renderGradient),
                state.cartesianGrid && renderCartesianGrid,
                state.xAxis && renderXAxis,
                state.yAxis && renderYAxis,
                renderChartsItems,
                state.tooltip && renderTooltip,
                state.brush && renderBrush,
                state.legend && renderLegend))));
};

export { Chart };
