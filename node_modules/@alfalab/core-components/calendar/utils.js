Object.defineProperty(exports, '__esModule', { value: true });

var dateFns = require('date-fns');

var DAYS_IN_WEEK = 7;
var MONTHS_IN_YEAR = 12;
var SUNDAY_INDEX = 6;
var DATE_FORMAT = 'dd.MM.yyyy';
var NATIVE_DATE_FORMAT = 'yyyy-MM-dd';
var WEEKDAYS = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
var MONTHS = [
    'Январь',
    'Февраль',
    'Март',
    'Апрель',
    'Май',
    'Июнь',
    'Июль',
    'Август',
    'Сентябрь',
    'Октябрь',
    'Ноябрь',
    'Декабрь',
];
/**
 * Возвращает «правильный» индекс дня недели, 0 - пн, 1 - вт и так далее.
 */
function russianWeekDay(date) {
    var sunday = 0;
    var foreignWeekDayIndex = date.getDay();
    return foreignWeekDayIndex === sunday ? DAYS_IN_WEEK - 1 : foreignWeekDayIndex - 1;
}
/**
 * Возвращает таблицу-календарь с заполненными датами для переданного месяца
 */
function generateWeeks(month, options) {
    var newWeek = function () { return Array(DAYS_IN_WEEK).fill(null); };
    var start = dateFns.startOfMonth(month);
    var end = dateFns.lastDayOfMonth(start);
    var week = newWeek();
    return dateFns.eachDayOfInterval({ start: start, end: end }).reduce(function (weeks, day) {
        var weekDay = russianWeekDay(day);
        week[weekDay] = buildDay(day, options);
        if (weekDay === SUNDAY_INDEX || dateFns.isSameDay(day, end)) {
            weeks.push(week);
            week = newWeek();
        }
        return weeks;
    }, []);
}
/**
 * Возвращает массив с месяцами для переданного года
 */
function generateMonths(year, options) {
    return dateFns.eachMonthOfInterval({ start: dateFns.startOfYear(year), end: dateFns.endOfYear(year) }).map(function (month) {
        return buildMonth(month, options);
    });
}
/**
 * Возвращает массив лет от minYear до maxYear
 */
function generateYears(minYear, maxYear) {
    return dateFns.eachYearOfInterval({
        start: dateFns.min([dateFns.startOfYear(maxYear), dateFns.startOfYear(minYear)]),
        end: dateFns.max([dateFns.startOfYear(maxYear), dateFns.startOfYear(minYear)]),
    }).reverse();
}
/**
 * Добавляет метаданные для переданного дня
 */
function buildDay(day, options) {
    var minDate = options.minDate, maxDate = options.maxDate, selected = options.selected, _a = options.eventsMap, eventsMap = _a === void 0 ? {} : _a, _b = options.offDaysMap, offDaysMap = _b === void 0 ? {} : _b;
    var off = offDaysMap[day.getTime()];
    var disabled = (minDate && dateFns.isBefore(day, minDate)) || (maxDate && dateFns.isAfter(day, maxDate));
    return {
        date: day,
        disabled: disabled || off,
        event: eventsMap[day.getTime()],
        selected: selected && dateFns.isSameDay(day, selected),
    };
}
/**
 * Добавляет метаданные для переданного месяца
 */
function buildMonth(month, options) {
    var minMonth = options.minMonth, maxMonth = options.maxMonth;
    return {
        date: month,
        disabled: (minMonth && dateFns.isBefore(month, minMonth)) || (maxMonth && dateFns.isAfter(month, maxMonth)),
    };
}
/**
 * Ограничивает дату на отрезке [minDate, maxDate]
 */
function limitDate(date, minDate, maxDate) {
    var limitedDate = date;
    if (minDate)
        limitedDate = dateFns.max([minDate, limitedDate]);
    if (maxDate)
        limitedDate = dateFns.min([maxDate, limitedDate]);
    return new Date(limitedDate);
}
/**
 * Проверяет, находится ли переданная дата в указанных границах
 */
function dateInLimits(date, minDate, maxDate) {
    return date && limitDate(date, minDate, maxDate).getTime() === new Date(date).getTime();
}
/**
 * Возвращает русское название месяца с большой буквы
 */
function monthName(month) {
    return MONTHS[month.getMonth()];
}
/**
 * Превращает массив в объект, у которого ключи составляются из элементов массива
 */
function dateArrayToHashTable(arr) {
    return arr.reduce(function (acc, v) {
        acc[dateFns.startOfDay(v).getTime()] = true;
        return acc;
    }, {});
}
/**
 * Возвращает корректный отрезок дат для выделения
 */
function getSelectionRange(from, to, highlighted) {
    var end = to || highlighted;
    if (from && end && from !== end) {
        return {
            start: dateFns.min([from, end]),
            end: dateFns.max([from, end]),
        };
    }
    return null;
}
// Меняет дату одним из способов с учетом границ и выходных дней
function modifyDateByShift(shift, date, minDate, maxDate, offDaysMap) {
    if (offDaysMap === void 0) { offDaysMap = {}; }
    var modifiers = {
        prev: function () { return dateFns.subDays(date, 1); },
        prevWeek: function () { return dateFns.subDays(date, 7); },
        prevMonth: function () { return dateFns.subMonths(date, 1); },
        next: function () { return dateFns.addDays(date, 1); },
        nextWeek: function () { return dateFns.addDays(date, 7); },
        nextMonth: function () { return dateFns.addMonths(date, 1); },
        startOfWeek: function () { return dateFns.startOfWeek(date, { weekStartsOn: 1 }); },
        endOfWeek: function () { return dateFns.startOfDay(dateFns.endOfWeek(date, { weekStartsOn: 1 })); },
    };
    var newDate = modifiers[shift]();
    while (offDaysMap[newDate.getTime()]) {
        // Перескакиваем через выходные дни, кроме случаев с концами недели
        var amount = newDate < date ? -1 : 1;
        if (shift === 'endOfWeek')
            amount = -1;
        if (shift === 'startOfWeek')
            amount = 1;
        newDate = dateFns.addDays(newDate, amount);
    }
    return limitDate(newDate, minDate, maxDate);
}
/**
 * Если дата была выбрана мышкой — фокусную обводку не видно
 * TODO: добавить в useFocus возможность переключать метод ввода программно
 */
function simulateTab(node) {
    if (window.KeyboardEvent) {
        var event_1 = new window.KeyboardEvent('keydown', {
            bubbles: true,
            key: 'Tab',
        });
        node.dispatchEvent(event_1);
    }
}
var formatDate = function (date, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DATE_FORMAT; }
    return dateFns.format(date, dateFormat);
};
var parseDateString = function (value, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DATE_FORMAT; }
    return dateFns.parse(value, dateFormat, new Date());
};

exports.DATE_FORMAT = DATE_FORMAT;
exports.DAYS_IN_WEEK = DAYS_IN_WEEK;
exports.MONTHS = MONTHS;
exports.MONTHS_IN_YEAR = MONTHS_IN_YEAR;
exports.NATIVE_DATE_FORMAT = NATIVE_DATE_FORMAT;
exports.SUNDAY_INDEX = SUNDAY_INDEX;
exports.WEEKDAYS = WEEKDAYS;
exports.buildDay = buildDay;
exports.buildMonth = buildMonth;
exports.dateArrayToHashTable = dateArrayToHashTable;
exports.dateInLimits = dateInLimits;
exports.formatDate = formatDate;
exports.generateMonths = generateMonths;
exports.generateWeeks = generateWeeks;
exports.generateYears = generateYears;
exports.getSelectionRange = getSelectionRange;
exports.limitDate = limitDate;
exports.modifyDateByShift = modifyDateByShift;
exports.monthName = monthName;
exports.parseDateString = parseDateString;
exports.russianWeekDay = russianWeekDay;
exports.simulateTab = simulateTab;
