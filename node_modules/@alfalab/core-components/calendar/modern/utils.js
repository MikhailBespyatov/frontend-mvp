import { startOfMonth, lastDayOfMonth, eachDayOfInterval, isSameDay, eachMonthOfInterval, startOfYear, endOfYear, isBefore, isAfter, eachYearOfInterval, min, max, startOfDay, addDays, format, parse, subDays, subMonths, addMonths, startOfWeek, endOfWeek } from 'date-fns';

const DAYS_IN_WEEK = 7;
const MONTHS_IN_YEAR = 12;
const SUNDAY_INDEX = 6;
const DATE_FORMAT = 'dd.MM.yyyy';
const NATIVE_DATE_FORMAT = 'yyyy-MM-dd';
const WEEKDAYS = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
const MONTHS = [
    'Январь',
    'Февраль',
    'Март',
    'Апрель',
    'Май',
    'Июнь',
    'Июль',
    'Август',
    'Сентябрь',
    'Октябрь',
    'Ноябрь',
    'Декабрь',
];
/**
 * Возвращает «правильный» индекс дня недели, 0 - пн, 1 - вт и так далее.
 */
function russianWeekDay(date) {
    const sunday = 0;
    const foreignWeekDayIndex = date.getDay();
    return foreignWeekDayIndex === sunday ? DAYS_IN_WEEK - 1 : foreignWeekDayIndex - 1;
}
/**
 * Возвращает таблицу-календарь с заполненными датами для переданного месяца
 */
function generateWeeks(month, options) {
    const newWeek = () => Array(DAYS_IN_WEEK).fill(null);
    const start = startOfMonth(month);
    const end = lastDayOfMonth(start);
    let week = newWeek();
    return eachDayOfInterval({ start, end }).reduce((weeks, day) => {
        const weekDay = russianWeekDay(day);
        week[weekDay] = buildDay(day, options);
        if (weekDay === SUNDAY_INDEX || isSameDay(day, end)) {
            weeks.push(week);
            week = newWeek();
        }
        return weeks;
    }, []);
}
/**
 * Возвращает массив с месяцами для переданного года
 */
function generateMonths(year, options) {
    return eachMonthOfInterval({ start: startOfYear(year), end: endOfYear(year) }).map(month => buildMonth(month, options));
}
/**
 * Возвращает массив лет от minYear до maxYear
 */
function generateYears(minYear, maxYear) {
    return eachYearOfInterval({
        start: min([startOfYear(maxYear), startOfYear(minYear)]),
        end: max([startOfYear(maxYear), startOfYear(minYear)]),
    }).reverse();
}
/**
 * Добавляет метаданные для переданного дня
 */
function buildDay(day, options) {
    const { minDate, maxDate, selected, eventsMap = {}, offDaysMap = {} } = options;
    const off = offDaysMap[day.getTime()];
    const disabled = (minDate && isBefore(day, minDate)) || (maxDate && isAfter(day, maxDate));
    return {
        date: day,
        disabled: disabled || off,
        event: eventsMap[day.getTime()],
        selected: selected && isSameDay(day, selected),
    };
}
/**
 * Добавляет метаданные для переданного месяца
 */
function buildMonth(month, options) {
    const { minMonth, maxMonth } = options;
    return {
        date: month,
        disabled: (minMonth && isBefore(month, minMonth)) || (maxMonth && isAfter(month, maxMonth)),
    };
}
/**
 * Ограничивает дату на отрезке [minDate, maxDate]
 */
function limitDate(date, minDate, maxDate) {
    let limitedDate = date;
    if (minDate)
        limitedDate = max([minDate, limitedDate]);
    if (maxDate)
        limitedDate = min([maxDate, limitedDate]);
    return new Date(limitedDate);
}
/**
 * Проверяет, находится ли переданная дата в указанных границах
 */
function dateInLimits(date, minDate, maxDate) {
    return date && limitDate(date, minDate, maxDate).getTime() === new Date(date).getTime();
}
/**
 * Возвращает русское название месяца с большой буквы
 */
function monthName(month) {
    return MONTHS[month.getMonth()];
}
/**
 * Превращает массив в объект, у которого ключи составляются из элементов массива
 */
function dateArrayToHashTable(arr) {
    return arr.reduce((acc, v) => {
        acc[startOfDay(v).getTime()] = true;
        return acc;
    }, {});
}
/**
 * Возвращает корректный отрезок дат для выделения
 */
function getSelectionRange(from, to, highlighted) {
    const end = to || highlighted;
    if (from && end && from !== end) {
        return {
            start: min([from, end]),
            end: max([from, end]),
        };
    }
    return null;
}
// Меняет дату одним из способов с учетом границ и выходных дней
function modifyDateByShift(shift, date, minDate, maxDate, offDaysMap = {}) {
    const modifiers = {
        prev: () => subDays(date, 1),
        prevWeek: () => subDays(date, 7),
        prevMonth: () => subMonths(date, 1),
        next: () => addDays(date, 1),
        nextWeek: () => addDays(date, 7),
        nextMonth: () => addMonths(date, 1),
        startOfWeek: () => startOfWeek(date, { weekStartsOn: 1 }),
        endOfWeek: () => startOfDay(endOfWeek(date, { weekStartsOn: 1 })),
    };
    let newDate = modifiers[shift]();
    while (offDaysMap[newDate.getTime()]) {
        // Перескакиваем через выходные дни, кроме случаев с концами недели
        let amount = newDate < date ? -1 : 1;
        if (shift === 'endOfWeek')
            amount = -1;
        if (shift === 'startOfWeek')
            amount = 1;
        newDate = addDays(newDate, amount);
    }
    return limitDate(newDate, minDate, maxDate);
}
/**
 * Если дата была выбрана мышкой — фокусную обводку не видно
 * TODO: добавить в useFocus возможность переключать метод ввода программно
 */
function simulateTab(node) {
    if (window.KeyboardEvent) {
        const event = new window.KeyboardEvent('keydown', {
            bubbles: true,
            key: 'Tab',
        });
        node.dispatchEvent(event);
    }
}
const formatDate = (date, dateFormat = DATE_FORMAT) => format(date, dateFormat);
const parseDateString = (value, dateFormat = DATE_FORMAT) => parse(value, dateFormat, new Date());

export { DATE_FORMAT, DAYS_IN_WEEK, MONTHS, MONTHS_IN_YEAR, NATIVE_DATE_FORMAT, SUNDAY_INDEX, WEEKDAYS, buildDay, buildMonth, dateArrayToHashTable, dateInLimits, formatDate, generateMonths, generateWeeks, generateYears, getSelectionRange, limitDate, modifyDateByShift, monthName, parseDateString, russianWeekDay, simulateTab };
