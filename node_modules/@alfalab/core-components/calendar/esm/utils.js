import { startOfMonth, lastDayOfMonth, eachDayOfInterval, isSameDay, eachMonthOfInterval, startOfYear, endOfYear, isBefore, isAfter, eachYearOfInterval, min, max, startOfDay, addDays, format, parse, subDays, subMonths, addMonths, startOfWeek, endOfWeek } from 'date-fns';

var DAYS_IN_WEEK = 7;
var MONTHS_IN_YEAR = 12;
var SUNDAY_INDEX = 6;
var DATE_FORMAT = 'dd.MM.yyyy';
var NATIVE_DATE_FORMAT = 'yyyy-MM-dd';
var WEEKDAYS = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
var MONTHS = [
    'Январь',
    'Февраль',
    'Март',
    'Апрель',
    'Май',
    'Июнь',
    'Июль',
    'Август',
    'Сентябрь',
    'Октябрь',
    'Ноябрь',
    'Декабрь',
];
/**
 * Возвращает «правильный» индекс дня недели, 0 - пн, 1 - вт и так далее.
 */
function russianWeekDay(date) {
    var sunday = 0;
    var foreignWeekDayIndex = date.getDay();
    return foreignWeekDayIndex === sunday ? DAYS_IN_WEEK - 1 : foreignWeekDayIndex - 1;
}
/**
 * Возвращает таблицу-календарь с заполненными датами для переданного месяца
 */
function generateWeeks(month, options) {
    var newWeek = function () { return Array(DAYS_IN_WEEK).fill(null); };
    var start = startOfMonth(month);
    var end = lastDayOfMonth(start);
    var week = newWeek();
    return eachDayOfInterval({ start: start, end: end }).reduce(function (weeks, day) {
        var weekDay = russianWeekDay(day);
        week[weekDay] = buildDay(day, options);
        if (weekDay === SUNDAY_INDEX || isSameDay(day, end)) {
            weeks.push(week);
            week = newWeek();
        }
        return weeks;
    }, []);
}
/**
 * Возвращает массив с месяцами для переданного года
 */
function generateMonths(year, options) {
    return eachMonthOfInterval({ start: startOfYear(year), end: endOfYear(year) }).map(function (month) {
        return buildMonth(month, options);
    });
}
/**
 * Возвращает массив лет от minYear до maxYear
 */
function generateYears(minYear, maxYear) {
    return eachYearOfInterval({
        start: min([startOfYear(maxYear), startOfYear(minYear)]),
        end: max([startOfYear(maxYear), startOfYear(minYear)]),
    }).reverse();
}
/**
 * Добавляет метаданные для переданного дня
 */
function buildDay(day, options) {
    var minDate = options.minDate, maxDate = options.maxDate, selected = options.selected, _a = options.eventsMap, eventsMap = _a === void 0 ? {} : _a, _b = options.offDaysMap, offDaysMap = _b === void 0 ? {} : _b;
    var off = offDaysMap[day.getTime()];
    var disabled = (minDate && isBefore(day, minDate)) || (maxDate && isAfter(day, maxDate));
    return {
        date: day,
        disabled: disabled || off,
        event: eventsMap[day.getTime()],
        selected: selected && isSameDay(day, selected),
    };
}
/**
 * Добавляет метаданные для переданного месяца
 */
function buildMonth(month, options) {
    var minMonth = options.minMonth, maxMonth = options.maxMonth;
    return {
        date: month,
        disabled: (minMonth && isBefore(month, minMonth)) || (maxMonth && isAfter(month, maxMonth)),
    };
}
/**
 * Ограничивает дату на отрезке [minDate, maxDate]
 */
function limitDate(date, minDate, maxDate) {
    var limitedDate = date;
    if (minDate)
        limitedDate = max([minDate, limitedDate]);
    if (maxDate)
        limitedDate = min([maxDate, limitedDate]);
    return new Date(limitedDate);
}
/**
 * Проверяет, находится ли переданная дата в указанных границах
 */
function dateInLimits(date, minDate, maxDate) {
    return date && limitDate(date, minDate, maxDate).getTime() === new Date(date).getTime();
}
/**
 * Возвращает русское название месяца с большой буквы
 */
function monthName(month) {
    return MONTHS[month.getMonth()];
}
/**
 * Превращает массив в объект, у которого ключи составляются из элементов массива
 */
function dateArrayToHashTable(arr) {
    return arr.reduce(function (acc, v) {
        acc[startOfDay(v).getTime()] = true;
        return acc;
    }, {});
}
/**
 * Возвращает корректный отрезок дат для выделения
 */
function getSelectionRange(from, to, highlighted) {
    var end = to || highlighted;
    if (from && end && from !== end) {
        return {
            start: min([from, end]),
            end: max([from, end]),
        };
    }
    return null;
}
// Меняет дату одним из способов с учетом границ и выходных дней
function modifyDateByShift(shift, date, minDate, maxDate, offDaysMap) {
    if (offDaysMap === void 0) { offDaysMap = {}; }
    var modifiers = {
        prev: function () { return subDays(date, 1); },
        prevWeek: function () { return subDays(date, 7); },
        prevMonth: function () { return subMonths(date, 1); },
        next: function () { return addDays(date, 1); },
        nextWeek: function () { return addDays(date, 7); },
        nextMonth: function () { return addMonths(date, 1); },
        startOfWeek: function () { return startOfWeek(date, { weekStartsOn: 1 }); },
        endOfWeek: function () { return startOfDay(endOfWeek(date, { weekStartsOn: 1 })); },
    };
    var newDate = modifiers[shift]();
    while (offDaysMap[newDate.getTime()]) {
        // Перескакиваем через выходные дни, кроме случаев с концами недели
        var amount = newDate < date ? -1 : 1;
        if (shift === 'endOfWeek')
            amount = -1;
        if (shift === 'startOfWeek')
            amount = 1;
        newDate = addDays(newDate, amount);
    }
    return limitDate(newDate, minDate, maxDate);
}
/**
 * Если дата была выбрана мышкой — фокусную обводку не видно
 * TODO: добавить в useFocus возможность переключать метод ввода программно
 */
function simulateTab(node) {
    if (window.KeyboardEvent) {
        var event_1 = new window.KeyboardEvent('keydown', {
            bubbles: true,
            key: 'Tab',
        });
        node.dispatchEvent(event_1);
    }
}
var formatDate = function (date, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DATE_FORMAT; }
    return format(date, dateFormat);
};
var parseDateString = function (value, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DATE_FORMAT; }
    return parse(value, dateFormat, new Date());
};

export { DATE_FORMAT, DAYS_IN_WEEK, MONTHS, MONTHS_IN_YEAR, NATIVE_DATE_FORMAT, SUNDAY_INDEX, WEEKDAYS, buildDay, buildMonth, dateArrayToHashTable, dateInLimits, formatDate, generateMonths, generateWeeks, generateYears, getSelectionRange, limitDate, modifyDateByShift, monthName, parseDateString, russianWeekDay, simulateTab };
