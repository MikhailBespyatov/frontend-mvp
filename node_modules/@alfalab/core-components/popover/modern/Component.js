import React, { forwardRef, useState, useRef, useCallback, useEffect } from 'react';
import cn from 'classnames';
import { CSSTransition } from 'react-transition-group';
import { usePopper } from 'react-popper';
import maxSize from 'popper-max-size-modifier';
import mergeRefs from 'react-merge-refs';
import { ResizeObserver } from 'resize-observer';
import { stackingOrder, Stack } from '../../stack/modern';
import { Portal } from '../../portal/modern';

var styles = {"component":"popover__component_dvtgo","inner":"popover__inner_dvtgo","scrollableContent":"popover__scrollableContent_dvtgo","arrow":"popover__arrow_dvtgo","arrowShift":"popover__arrowShift_dvtgo","enter":"popover__enter_dvtgo","enterActive":"popover__enterActive_dvtgo","exit":"popover__exit_dvtgo","exitActive":"popover__exitActive_dvtgo"};
require('./index.css');

const DEFAULT_TRANSITION = {
    timeout: 150,
};
const CSS_TRANSITION_CLASS_NAMES = {
    enter: styles.enter,
    enterActive: styles.enterActive,
    exit: styles.exit,
    exitActive: styles.exitActive,
};
const availableHieghtModifier = {
    name: 'availableHeight',
    enabled: true,
    phase: 'beforeWrite',
    requires: ['maxSize'],
    fn({ state: { modifiersData, elements: { popper }, }, }) {
        const { height } = modifiersData.maxSize;
        const content = popper.querySelector(`.${styles.scrollableContent}`);
        if (content && !content.style.maxHeight) {
            content.style.maxHeight = `${height}px`;
        }
    },
};
/**
 * Минимальный размер anchorElement,
 * при котором возможно смещение стрелочки относительно центра
 */
const MIN_ARROW_SHIFT_SIZE = 75;
const Popover = forwardRef(({ children, getPortalContainer, transition = DEFAULT_TRANSITION, anchorElement, useAnchorWidth, offset = [0, 0], withArrow = false, withTransition = true, position = 'left', preventFlip, popperClassName, arrowClassName, className, open, dataTestId, update, transitionDuration = `${transition.timeout}ms`, zIndex = stackingOrder.POPOVER, fallbackPlacements, preventOverflow = true, availableHeight = false, }, ref) => {
    const [referenceElement, setReferenceElement] = useState(anchorElement);
    const [popperElement, setPopperElement] = useState(null);
    const [arrowElement, setArrowElement] = useState(null);
    const [arrowShift, setArrowShift] = useState(false);
    const updatePopperRef = useRef();
    const getModifiers = useCallback(() => {
        const modifiers = [{ name: 'offset', options: { offset } }];
        if (withArrow) {
            modifiers.push({ name: 'arrow', options: { element: arrowElement } });
        }
        if (preventFlip) {
            modifiers.push({ name: 'flip', options: { fallbackPlacements: [] } });
        }
        if (fallbackPlacements) {
            modifiers.push({ name: 'flip', options: { fallbackPlacements } });
        }
        if (preventOverflow) {
            modifiers.push({ name: 'preventOverflow', options: { mainAxis: false } });
        }
        if (availableHeight) {
            modifiers.push({ ...maxSize, options: {} });
            modifiers.push({ ...availableHieghtModifier, options: {} });
        }
        return modifiers;
    }, [
        offset,
        withArrow,
        preventFlip,
        fallbackPlacements,
        preventOverflow,
        availableHeight,
        arrowElement,
    ]);
    const { styles: popperStyles, attributes, update: updatePopper } = usePopper(referenceElement, popperElement, {
        placement: position,
        modifiers: getModifiers(),
    });
    if (updatePopper) {
        updatePopperRef.current = updatePopper;
    }
    const updatePopoverWidth = useCallback(() => {
        if (useAnchorWidth && updatePopperRef.current) {
            updatePopperRef.current();
        }
    }, [useAnchorWidth]);
    useEffect(() => {
        setReferenceElement(anchorElement);
    }, [anchorElement]);
    useEffect(() => {
        if (updatePopper) {
            updatePopper();
        }
    }, [updatePopper, arrowElement, children]);
    useEffect(() => {
        if (update && !update.current && updatePopper) {
            // eslint-disable-next-line no-param-reassign
            update.current = updatePopper;
        }
    });
    useEffect(() => {
        if (useAnchorWidth) {
            const observer = new ResizeObserver(updatePopoverWidth);
            if (anchorElement) {
                observer.observe(anchorElement);
            }
            return () => {
                observer.disconnect();
            };
        }
        return () => ({});
    }, [anchorElement, updatePopoverWidth, useAnchorWidth]);
    /**
     * По дизайну, если у тултипа позиционирование -start/-end, то стрелочка немного сдвигается вбок.
     * Но если anchorElement слишком маленький, то стрелочка сдвигаться не должна.
     */
    useEffect(() => {
        const shiftedPosition = position.includes('-start') || position.includes('-end');
        if (shiftedPosition && referenceElement) {
            const { width, height } = referenceElement.getBoundingClientRect();
            const size = position.includes('left') || position.includes('right') ? height : width;
            if (size >= MIN_ARROW_SHIFT_SIZE) {
                setArrowShift(true);
            }
        }
    }, [referenceElement, position]);
    const renderContent = (computedZIndex, style) => {
        return (React.createElement("div", Object.assign({ ref: mergeRefs([ref, setPopperElement]), style: {
                zIndex: computedZIndex,
                width: useAnchorWidth ? referenceElement?.offsetWidth : undefined,
                ...popperStyles.popper,
            }, "data-test-id": dataTestId, className: cn(styles.component, className, {
                [styles.arrowShift]: arrowShift,
            }) }, attributes.popper),
            React.createElement("div", { className: cn(styles.inner, popperClassName), style: style },
                React.createElement("div", { className: cn({ [styles.scrollableContent]: availableHeight }) }, children),
                withArrow && (React.createElement("div", { ref: setArrowElement, style: popperStyles.arrow, className: cn(styles.arrow, arrowClassName) })))));
    };
    return (React.createElement(Stack, { value: zIndex }, computedZIndex => (React.createElement(Portal, { getPortalContainer: getPortalContainer }, withTransition ? (React.createElement(CSSTransition, Object.assign({ unmountOnExit: true, classNames: CSS_TRANSITION_CLASS_NAMES }, transition, { in: open }), renderContent(computedZIndex, { transitionDuration }))) : (open && renderContent(computedZIndex))))));
});

export { Popover };
