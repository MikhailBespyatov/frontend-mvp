// Generated by dts-bundle-generator v6.12.0

import React from 'react';
import { useEffect } from 'react';

export declare function useClickOutside(ref: React.RefObject<HTMLElement> | Array<React.RefObject<HTMLElement>>, cb: (e: MouseEvent | TouchEvent) => void): void;
export declare type UseCountdownArgs = {
	endDate: Date;
	onStart?: () => void;
	onEnd?: () => void;
};
export declare type UseCountdownHook = [
	number
];
/**
 * Хук обратного отсчёта времени.
 * Возвращает оставшееся количество секунд до определённой даты.
 *
 * @param params.endDate - Дата окончания
 * @param params.onStart - Функция, которая будет вызвана при запуске счётчика
 * @param params.onEnd - Функция, которая будет вызвана при окончании счётчика
 */
export declare function useCountdown({ endDate, onStart, onEnd }: UseCountdownArgs): UseCountdownHook;
export declare type DimensionObject = DOMRectReadOnly;
export declare type UseDimensionsHook = [
	(node: HTMLElement) => void,
	DimensionObject | undefined,
	HTMLElement | undefined
];
export interface UseDimensionsArgs {
	liveMeasure?: boolean;
}
export declare function useDimensions({ liveMeasure }?: UseDimensionsArgs): UseDimensionsHook;
/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 *
 * @param {function} fn
 */
export declare function useEventCallback(fn: (...args: any) => any): (...args: any[]) => any;
export declare type InputMethod = "keyboard" | "mouse";
/**
 * Хук устанавливает обработчик события на focusin и focusout
 * по конкретному типу события
 * @param node Элемент на котором установится обработчик (default = document)
 * @param inputMethod Если параметр не задан, установит обработчик по любому событию фокуса
 */
export declare function useFocus<T extends HTMLElement>(ref: React.MutableRefObject<T> | React.RefObject<T>, inputMethod?: InputMethod): [
	boolean
];
export declare function useKeydownOutside(ref: React.RefObject<HTMLElement>, cb: (e: KeyboardEvent) => void): void;
export declare type Query<T> = [
	T,
	string
];
export declare type Params<T> = Array<Query<T>>;
export declare function useMedia<T>(list: Params<T>, defaultValue: T): T[];
export declare function usePrevious<T>(value: T): T | undefined;
export declare function useDidUpdateEffect(effect: () => void | (() => void), deps: unknown[]): void;
export declare type UseImageLoadingStateArgs = {
	src: string;
};
declare enum UseLoadingStates {
	LOADED = "loaded",
	LOADING = "loading",
	ERROR = "error"
}
/**
 * Возвращает результат загрузки изображения
 * @param params.src url изображения
 * @return результат загрузки (loading | loaded | error)
 */
export declare function useImageLoadingState({ src }: UseImageLoadingStateArgs): UseLoadingStates;
export declare function useScrolledToBottomOfPage(cb: () => void, once?: boolean): void;
export declare function useForceUpdate(): () => void;
/**
 * Возвращаемый хуком метод, для определения доступности компонента.
 */
export declare type UseIsMountedResult = () => boolean;
/**
 * Хук получения состояния доступности компонента.
 */
export declare const useIsMounted: () => UseIsMountedResult;
export declare const useId: () => string;
/**
 * Обновление состояния, только если компонент смонтирован
 * Устраняет утечку и варнинги
 */
export declare const useStateIfMounted: <T>(initialValue: T | (() => T)) => [
	T,
	React.Dispatch<React.SetStateAction<T>>
];
export declare const useLayoutEffect_SAFE_FOR_SSR: typeof useEffect;

export {};
