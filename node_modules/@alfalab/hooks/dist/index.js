'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var utils = require('@alfalab/utils');
var uuid = require('uuid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function useClickOutside(ref, cb) {
    React__default["default"].useEffect(function () {
        var handler = function (event) {
            var checkClickedElement = function (el) {
                return !el.current || el.current.contains(event.target);
            };
            if ((Array.isArray(ref) && ref.find(checkClickedElement)) ||
                (!Array.isArray(ref) && checkClickedElement(ref))) {
                return;
            }
            cb(event);
        };
        document.addEventListener('mousedown', handler);
        document.addEventListener('touchstart', handler);
        return function () {
            document.removeEventListener('mousedown', handler);
            document.removeEventListener('touchstart', handler);
        };
    }, [ref, cb]);
}

/**
 * Хук обратного отсчёта времени.
 * Возвращает оставшееся количество секунд до определённой даты.
 *
 * @param params.endDate - Дата окончания
 * @param params.onStart - Функция, которая будет вызвана при запуске счётчика
 * @param params.onEnd - Функция, которая будет вызвана при окончании счётчика
 */
function useCountdown(_a) {
    var endDate = _a.endDate, onStart = _a.onStart, onEnd = _a.onEnd;
    var intervalId = React.useRef(null);
    var _b = React.useState(differenceInSeconds(endDate, new Date())), seconds = _b[0], setSeconds = _b[1];
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var clear = React.useCallback(function () { return clearInterval(intervalId.current); }, []);
    React.useEffect(function () {
        if (onStart) {
            onStart();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    React.useEffect(function () {
        intervalId.current = setInterval(function () {
            setSeconds(function (sec) { return sec - 1; });
        }, 1000);
        return clear;
    }, [clear]);
    React.useEffect(function () {
        if (seconds <= 0) {
            clear();
            if (onEnd) {
                onEnd();
            }
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [seconds]);
    return [seconds];
}
function differenceInSeconds(dateLeft, dateRight) {
    var diff = (dateLeft.getTime() - dateRight.getTime()) / 1000;
    return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

function getDimensionObject(node) {
    return node.getBoundingClientRect();
}
function useDimensions(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.liveMeasure, liveMeasure = _c === void 0 ? true : _c;
    var _d = React.useState(), dimensions = _d[0], setDimensions = _d[1];
    var _e = React.useState(), node = _e[0], setNode = _e[1];
    var ref = React.useCallback(function (_node) {
        setNode(_node);
    }, []);
    React.useLayoutEffect(function () {
        if (node) {
            var measure_1 = function () {
                return window.requestAnimationFrame(function () { return setDimensions(getDimensionObject(node)); });
            };
            measure_1();
            if (liveMeasure) {
                window.addEventListener('resize', measure_1);
                window.addEventListener('scroll', measure_1);
                return function () {
                    window.removeEventListener('resize', measure_1);
                    window.removeEventListener('scroll', measure_1);
                };
            }
        }
        return function () { return undefined; };
    }, [node, liveMeasure]);
    return [ref, dimensions, node];
}

/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 *
 * @param {function} fn
 */
function useEventCallback(fn) {
    var ref = React__default["default"].useRef(fn);
    React__default["default"].useEffect(function () {
        ref.current = fn;
    });
    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
    // @ts-ignore
    return React__default["default"].useCallback(function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (ref.current).apply(void 0, args);
    }, []);
}

var prevInputMethod;
function handleKeyDown(event) {
    if (event.key === 'Tab') {
        prevInputMethod = 'keyboard';
    }
}
function handleMouseDown() {
    prevInputMethod = 'mouse';
}
function handleTouchStart() {
    prevInputMethod = 'mouse';
}
/**
 * Навешивает несколько глобальных обработчиков и отслеживает метод ввода - мышь или клавиатура.
 * Note: Повторный вызов функции не дублирует обработчики
 */
function addGlobalListeners() {
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('touchstart', handleTouchStart);
}
/**
 * Хук устанавливает обработчик события на focusin и focusout
 * по конкретному типу события
 * @param node Элемент на котором установится обработчик (default = document)
 * @param inputMethod Если параметр не задан, установит обработчик по любому событию фокуса
 */
function useFocus(ref, inputMethod) {
    var _a = React__default["default"].useState(false), focus = _a[0], setFocus = _a[1];
    var handleFocus = React__default["default"].useCallback(function () {
        if (!inputMethod || inputMethod === prevInputMethod) {
            setFocus(true);
        }
    }, [inputMethod]);
    var handleBlur = React__default["default"].useCallback(function () {
        setFocus(false);
    }, []);
    React__default["default"].useEffect(function () {
        var node = ref.current;
        if (node) {
            node.addEventListener('focusin', handleFocus);
            node.addEventListener('focusout', handleBlur);
        }
        return function () {
            if (node) {
                node.removeEventListener('focusin', handleFocus);
                node.removeEventListener('focusout', handleBlur);
            }
        };
    }, [handleBlur, handleFocus, ref]);
    React__default["default"].useEffect(addGlobalListeners, []);
    return [focus];
}

function useKeydownOutside(ref, cb) {
    React__default["default"].useEffect(function () {
        var handler = function (event) {
            if (!ref.current || (event.target instanceof Node && ref.current.contains(event.target))) {
                return;
            }
            cb(event);
        };
        document.addEventListener('keydown', handler);
        return function () {
            document.removeEventListener('keydown', handler);
        };
    }, [ref, cb]);
}

/* eslint-disable @typescript-eslint/no-unused-vars */
function getValue(list) {
    return list.map(
    // eslint-disable-next-line no-confusing-arrow
    function (_a) {
        var value = _a[0], query = _a[1];
        return query.matches ? value : null;
    }).filter(Boolean);
}
function useMedia(list, defaultValue) {
    var _a = React__default["default"].useState([defaultValue]), value = _a[0], setValue = _a[1];
    var _b = React__default["default"].useState([]), mediaQueryList = _b[0], setMediaQueryList = _b[1];
    var isClient = typeof window !== 'undefined';
    React__default["default"].useEffect(function () {
        if (isClient && window.matchMedia) {
            var queryList = list.map(function (_a) {
                var x = _a[0], y = _a[1];
                return [x, window.matchMedia(y)];
            });
            setMediaQueryList(queryList);
            setValue(getValue(queryList));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isClient]);
    React__default["default"].useEffect(function () {
        var handler = function () {
            setValue(getValue(mediaQueryList));
        };
        mediaQueryList.forEach(function (_a) {
            _a[0]; var mediaQuery = _a[1];
            return mediaQuery.addListener(handler);
        });
        return function () {
            mediaQueryList
                .forEach(function (_a) {
                _a[0]; var mediaQuery = _a[1];
                return mediaQuery.removeListener(handler);
            });
        };
    }, [value, mediaQueryList]);
    return value;
}

function usePrevious(value) {
    var ref = React__default["default"].useRef();
    React__default["default"].useEffect(function () {
        ref.current = value;
    });
    return ref.current;
}

function useDidUpdateEffect(effect, deps) {
    var didMountRef = React__default["default"].useRef(false);
    // eslint-disable-next-line consistent-return
    React__default["default"].useEffect(function () {
        if (didMountRef.current) {
            var cleanup_1 = effect();
            if (cleanup_1) {
                return function () { return cleanup_1(); };
            }
        }
        didMountRef.current = true;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}

var UseLoadingStates;
(function (UseLoadingStates) {
    UseLoadingStates["LOADED"] = "loaded";
    UseLoadingStates["LOADING"] = "loading";
    UseLoadingStates["ERROR"] = "error";
})(UseLoadingStates || (UseLoadingStates = {}));

/**
 * Возвращает результат загрузки изображения
 * @param params.src url изображения
 * @return результат загрузки (loading | loaded | error)
 */
function useImageLoadingState(_a) {
    var src = _a.src;
    var _b = React.useState(UseLoadingStates.LOADING), loadingState = _b[0], setLoadingState = _b[1];
    React.useEffect(function () {
        var active = true;
        setLoadingState(UseLoadingStates.LOADING);
        var image = new Image();
        image.onload = function () {
            if (!active) {
                return;
            }
            setLoadingState(UseLoadingStates.LOADED);
        };
        image.onerror = function () {
            if (!active) {
                return;
            }
            setLoadingState(UseLoadingStates.ERROR);
        };
        image.srcset = src;
        return function () {
            active = false;
        };
    }, [src]);
    return loadingState;
}

function useScrolledToBottomOfPage(cb, once) {
    if (once === void 0) { once = true; }
    React__default["default"].useEffect(function () {
        var handler = function () {
            if (utils.hasScrolledToBottomOfPage()) {
                cb();
                if (once) {
                    document.removeEventListener('scroll', handler);
                }
            }
        };
        document.addEventListener('scroll', handler);
        return function () {
            document.removeEventListener('scroll', handler);
        };
    }, [cb]);
}

function useForceUpdate() {
    var _a = React.useState(Object.create(null)), dispatch = _a[1];
    var memoizedDispatch = React.useCallback(function () {
        dispatch(Object.create(null));
    }, [dispatch]);
    return memoizedDispatch;
}

/**
 * Хук получения состояния доступности компонента.
 */
var useIsMounted = function () {
    var isMounted = React.useRef(true);
    React.useEffect(function () { return function () {
        isMounted.current = false;
    }; }, []);
    return React.useCallback(function () { return isMounted.current; }, []);
};

var useId = React__default["default"].useId || function useUuid() {
    /*
     * Utilize useState instead of useMemo because React
     * makes no guarantees that the memo store is durable
     */
    var id = React__default["default"].useState(function () { return uuid.v4(); })[0];
    return id;
};

/**
 * Обновление состояния, только если компонент смонтирован
 * Устраняет утечку и варнинги
 */
var useStateIfMounted = function (initialValue) {
    var getIsMounted = useIsMounted();
    var _a = React__default["default"].useState(initialValue), storedValue = _a[0], setStoredValue = _a[1];
    var setState = React__default["default"].useCallback(function (value) {
        var isMounted = getIsMounted();
        if (isMounted) {
            setStoredValue(value);
        }
    }, [getIsMounted]);
    return [storedValue, setState];
};

// eslint-disable-next-line @typescript-eslint/naming-convention
var useLayoutEffect_SAFE_FOR_SSR = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;

exports.useClickOutside = useClickOutside;
exports.useCountdown = useCountdown;
exports.useDidUpdateEffect = useDidUpdateEffect;
exports.useDimensions = useDimensions;
exports.useEventCallback = useEventCallback;
exports.useFocus = useFocus;
exports.useForceUpdate = useForceUpdate;
exports.useId = useId;
exports.useImageLoadingState = useImageLoadingState;
exports.useIsMounted = useIsMounted;
exports.useKeydownOutside = useKeydownOutside;
exports.useLayoutEffect_SAFE_FOR_SSR = useLayoutEffect_SAFE_FOR_SSR;
exports.useMedia = useMedia;
exports.usePrevious = usePrevious;
exports.useScrolledToBottomOfPage = useScrolledToBottomOfPage;
exports.useStateIfMounted = useStateIfMounted;
